/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.ActivityCursorPage
import org.openapitools.client.models.ActivityItem
import org.openapitools.client.models.Agile
import org.openapitools.client.models.AppearanceSettings
import org.openapitools.client.models.Article
import org.openapitools.client.models.ArticleAttachment
import org.openapitools.client.models.ArticleComment
import org.openapitools.client.models.BackupFile
import org.openapitools.client.models.BackupStatus
import org.openapitools.client.models.BuildBundle
import org.openapitools.client.models.BuildBundleElement
import org.openapitools.client.models.CommandList
import org.openapitools.client.models.CustomField
import org.openapitools.client.models.CustomFieldDefaults
import org.openapitools.client.models.DatabaseBackupSettings
import org.openapitools.client.models.EnumBundle
import org.openapitools.client.models.EnumBundleElement
import org.openapitools.client.models.FieldType
import org.openapitools.client.models.GeneralUserProfile
import org.openapitools.client.models.GlobalSettings
import org.openapitools.client.models.GlobalTimeTrackingSettings
import org.openapitools.client.models.Issue
import org.openapitools.client.models.IssueAttachment
import org.openapitools.client.models.IssueComment
import org.openapitools.client.models.IssueCountResponse
import org.openapitools.client.models.IssueCustomField
import org.openapitools.client.models.IssueLink
import org.openapitools.client.models.IssueLinkType
import org.openapitools.client.models.IssueTimeTracker
import org.openapitools.client.models.IssueWorkItem
import org.openapitools.client.models.License
import org.openapitools.client.models.LocaleSettings
import org.openapitools.client.models.Me
import org.openapitools.client.models.NotificationSettings
import org.openapitools.client.models.NotificationsUserProfile
import org.openapitools.client.models.OwnedBundle
import org.openapitools.client.models.OwnedBundleElement
import org.openapitools.client.models.Project
import org.openapitools.client.models.ProjectCustomField
import org.openapitools.client.models.ProjectTimeTrackingSettings
import org.openapitools.client.models.RestCorsSettings
import org.openapitools.client.models.SavedQuery
import org.openapitools.client.models.SearchSuggestions
import org.openapitools.client.models.Sprint
import org.openapitools.client.models.StateBundle
import org.openapitools.client.models.StateBundleElement
import org.openapitools.client.models.SystemSettings
import org.openapitools.client.models.Tag
import org.openapitools.client.models.Telemetry
import org.openapitools.client.models.TimeTrackingUserProfile
import org.openapitools.client.models.User
import org.openapitools.client.models.UserBundle
import org.openapitools.client.models.UserGroup
import org.openapitools.client.models.VcsChange
import org.openapitools.client.models.VersionBundle
import org.openapitools.client.models.VersionBundleElement
import org.openapitools.client.models.WorkItemType
import org.openapitools.client.models.WorkTimeSettings

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class DefaultApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://itech-infra.youtrack.cloud:443/api")
        }
    }

    /**
     * 
     * 
     * @param categories  (optional)
     * @param reverse Indicates whether the order of returning activities is from newest to oldest or the opposite. If \&quot;false\&quot;, then the oldest activity item that matches a selected filter is returned first. If \&quot;true\&quot;, then the newest activity is returned first. By default, \&quot;false\&quot;. (optional)
     * @param start Start timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered to be 0. (optional)
     * @param end End timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered as Long.MAX_VALUE. (optional)
     * @param author Parameter to filter activities by the author. The database id or login, or Hub id, or &#39;me&#39; for the current logged in user could be specified. (optional)
     * @param issueQuery Issues search query. Read more about &lt;a href&#x3D;\&quot;Search-and-Command-Attributes.xml\&quot;&gt;search syntax&lt;/a&gt;. (optional)
     * @param fields  (optional, default to "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<ActivityItem>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun activitiesGet(categories: kotlin.String? = null, reverse: kotlin.Boolean? = null, start: kotlin.String? = null, end: kotlin.String? = null, author: kotlin.String? = null, issueQuery: kotlin.String? = null, fields: kotlin.String? = "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<ActivityItem> {
        val localVarResponse = activitiesGetWithHttpInfo(categories = categories, reverse = reverse, start = start, end = end, author = author, issueQuery = issueQuery, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ActivityItem>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param categories  (optional)
     * @param reverse Indicates whether the order of returning activities is from newest to oldest or the opposite. If \&quot;false\&quot;, then the oldest activity item that matches a selected filter is returned first. If \&quot;true\&quot;, then the newest activity is returned first. By default, \&quot;false\&quot;. (optional)
     * @param start Start timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered to be 0. (optional)
     * @param end End timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered as Long.MAX_VALUE. (optional)
     * @param author Parameter to filter activities by the author. The database id or login, or Hub id, or &#39;me&#39; for the current logged in user could be specified. (optional)
     * @param issueQuery Issues search query. Read more about &lt;a href&#x3D;\&quot;Search-and-Command-Attributes.xml\&quot;&gt;search syntax&lt;/a&gt;. (optional)
     * @param fields  (optional, default to "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<ActivityItem>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun activitiesGetWithHttpInfo(categories: kotlin.String?, reverse: kotlin.Boolean?, start: kotlin.String?, end: kotlin.String?, author: kotlin.String?, issueQuery: kotlin.String?, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<ActivityItem>?> {
        val localVariableConfig = activitiesGetRequestConfig(categories = categories, reverse = reverse, start = start, end = end, author = author, issueQuery = issueQuery, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<ActivityItem>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation activitiesGet
     *
     * @param categories  (optional)
     * @param reverse Indicates whether the order of returning activities is from newest to oldest or the opposite. If \&quot;false\&quot;, then the oldest activity item that matches a selected filter is returned first. If \&quot;true\&quot;, then the newest activity is returned first. By default, \&quot;false\&quot;. (optional)
     * @param start Start timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered to be 0. (optional)
     * @param end End timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered as Long.MAX_VALUE. (optional)
     * @param author Parameter to filter activities by the author. The database id or login, or Hub id, or &#39;me&#39; for the current logged in user could be specified. (optional)
     * @param issueQuery Issues search query. Read more about &lt;a href&#x3D;\&quot;Search-and-Command-Attributes.xml\&quot;&gt;search syntax&lt;/a&gt;. (optional)
     * @param fields  (optional, default to "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun activitiesGetRequestConfig(categories: kotlin.String?, reverse: kotlin.Boolean?, start: kotlin.String?, end: kotlin.String?, author: kotlin.String?, issueQuery: kotlin.String?, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (categories != null) {
                    put("categories", listOf(categories.toString()))
                }
                if (reverse != null) {
                    put("reverse", listOf(reverse.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (end != null) {
                    put("end", listOf(end.toString()))
                }
                if (author != null) {
                    put("author", listOf(author.toString()))
                }
                if (issueQuery != null) {
                    put("issueQuery", listOf(issueQuery.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/activities",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp")
     * @return ActivityItem
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun activitiesIdGet(id: kotlin.String, fields: kotlin.String? = "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp") : ActivityItem {
        val localVarResponse = activitiesIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ActivityItem
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp")
     * @return ApiResponse<ActivityItem?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun activitiesIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<ActivityItem?> {
        val localVariableConfig = activitiesIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, ActivityItem>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation activitiesIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp")
     * @return RequestConfig
     */
    fun activitiesIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/activities/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param categories  (optional)
     * @param reverse Indicates whether the order of returning activities is from newest to oldest or the opposite. If \&quot;false\&quot;, then the oldest activity item that matches a selected filter is returned first. If \&quot;true\&quot;, then the newest activity is returned first. By default, \&quot;false\&quot;. (optional)
     * @param start Start timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered to be 0. (optional)
     * @param end End timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered as Long.MAX_VALUE. (optional)
     * @param author Parameter to filter activities by the author. The database id or login, or Hub id, or &#39;me&#39; for the current logged in user could be specified. (optional)
     * @param issueQuery Issues search query. Read more about &lt;a href&#x3D;\&quot;Search-and-Command-Attributes.xml\&quot;&gt;search syntax&lt;/a&gt;. (optional)
     * @param cursor  (optional)
     * @param activityId ID of the activity that should be included in the page. The activity is allocated to the middle of the page. (optional)
     * @param fields  (optional, default to "$type,activities($type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp),afterCursor,beforeCursor,hasAfter,hasBefore,id")
     * @return ActivityCursorPage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun activitiesPageGet(categories: kotlin.String? = null, reverse: kotlin.Boolean? = null, start: kotlin.String? = null, end: kotlin.String? = null, author: kotlin.String? = null, issueQuery: kotlin.String? = null, cursor: kotlin.String? = null, activityId: kotlin.String? = null, fields: kotlin.String? = "$type,activities($type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp),afterCursor,beforeCursor,hasAfter,hasBefore,id") : ActivityCursorPage {
        val localVarResponse = activitiesPageGetWithHttpInfo(categories = categories, reverse = reverse, start = start, end = end, author = author, issueQuery = issueQuery, cursor = cursor, activityId = activityId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ActivityCursorPage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param categories  (optional)
     * @param reverse Indicates whether the order of returning activities is from newest to oldest or the opposite. If \&quot;false\&quot;, then the oldest activity item that matches a selected filter is returned first. If \&quot;true\&quot;, then the newest activity is returned first. By default, \&quot;false\&quot;. (optional)
     * @param start Start timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered to be 0. (optional)
     * @param end End timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered as Long.MAX_VALUE. (optional)
     * @param author Parameter to filter activities by the author. The database id or login, or Hub id, or &#39;me&#39; for the current logged in user could be specified. (optional)
     * @param issueQuery Issues search query. Read more about &lt;a href&#x3D;\&quot;Search-and-Command-Attributes.xml\&quot;&gt;search syntax&lt;/a&gt;. (optional)
     * @param cursor  (optional)
     * @param activityId ID of the activity that should be included in the page. The activity is allocated to the middle of the page. (optional)
     * @param fields  (optional, default to "$type,activities($type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp),afterCursor,beforeCursor,hasAfter,hasBefore,id")
     * @return ApiResponse<ActivityCursorPage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun activitiesPageGetWithHttpInfo(categories: kotlin.String?, reverse: kotlin.Boolean?, start: kotlin.String?, end: kotlin.String?, author: kotlin.String?, issueQuery: kotlin.String?, cursor: kotlin.String?, activityId: kotlin.String?, fields: kotlin.String?) : ApiResponse<ActivityCursorPage?> {
        val localVariableConfig = activitiesPageGetRequestConfig(categories = categories, reverse = reverse, start = start, end = end, author = author, issueQuery = issueQuery, cursor = cursor, activityId = activityId, fields = fields)

        return request<Unit, ActivityCursorPage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation activitiesPageGet
     *
     * @param categories  (optional)
     * @param reverse Indicates whether the order of returning activities is from newest to oldest or the opposite. If \&quot;false\&quot;, then the oldest activity item that matches a selected filter is returned first. If \&quot;true\&quot;, then the newest activity is returned first. By default, \&quot;false\&quot;. (optional)
     * @param start Start timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered to be 0. (optional)
     * @param end End timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered as Long.MAX_VALUE. (optional)
     * @param author Parameter to filter activities by the author. The database id or login, or Hub id, or &#39;me&#39; for the current logged in user could be specified. (optional)
     * @param issueQuery Issues search query. Read more about &lt;a href&#x3D;\&quot;Search-and-Command-Attributes.xml\&quot;&gt;search syntax&lt;/a&gt;. (optional)
     * @param cursor  (optional)
     * @param activityId ID of the activity that should be included in the page. The activity is allocated to the middle of the page. (optional)
     * @param fields  (optional, default to "$type,activities($type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp),afterCursor,beforeCursor,hasAfter,hasBefore,id")
     * @return RequestConfig
     */
    fun activitiesPageGetRequestConfig(categories: kotlin.String?, reverse: kotlin.Boolean?, start: kotlin.String?, end: kotlin.String?, author: kotlin.String?, issueQuery: kotlin.String?, cursor: kotlin.String?, activityId: kotlin.String?, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (categories != null) {
                    put("categories", listOf(categories.toString()))
                }
                if (reverse != null) {
                    put("reverse", listOf(reverse.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (end != null) {
                    put("end", listOf(end.toString()))
                }
                if (author != null) {
                    put("author", listOf(author.toString()))
                }
                if (issueQuery != null) {
                    put("issueQuery", listOf(issueQuery.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (activityId != null) {
                    put("activityId", listOf(activityId.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/activitiesPage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<BuildBundle>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesBuildGet(fields: kotlin.String? = "$type,id", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<BuildBundle> {
        val localVarResponse = adminCustomFieldSettingsBundlesBuildGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BuildBundle>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<BuildBundle>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesBuildGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<BuildBundle>?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesBuildGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<BuildBundle>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesBuildGet
     *
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesBuildGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/build",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesBuildIdDelete(id: kotlin.String) : Unit {
        val localVarResponse = adminCustomFieldSettingsBundlesBuildIdDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesBuildIdDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesBuildIdDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesBuildIdDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesBuildIdDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/customFieldSettings/bundles/build/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return BuildBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesBuildIdGet(id: kotlin.String, fields: kotlin.String? = "$type,id") : BuildBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesBuildIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BuildBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return ApiResponse<BuildBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesBuildIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<BuildBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesBuildIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, BuildBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesBuildIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesBuildIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/build/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param buildBundle  (optional)
     * @return BuildBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesBuildIdPost(id: kotlin.String, fields: kotlin.String? = "$type,id", buildBundle: BuildBundle? = null) : BuildBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesBuildIdPostWithHttpInfo(id = id, fields = fields, buildBundle = buildBundle)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BuildBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param buildBundle  (optional)
     * @return ApiResponse<BuildBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesBuildIdPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, buildBundle: BuildBundle?) : ApiResponse<BuildBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesBuildIdPostRequestConfig(id = id, fields = fields, buildBundle = buildBundle)

        return request<BuildBundle, BuildBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesBuildIdPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param buildBundle  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesBuildIdPostRequestConfig(id: kotlin.String, fields: kotlin.String?, buildBundle: BuildBundle?) : RequestConfig<BuildBundle> {
        val localVariableBody = buildBundle
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/build/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param buildBundleElementId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdDelete(id: kotlin.String, buildBundleElementId: kotlin.String) : Unit {
        val localVarResponse = adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdDeleteWithHttpInfo(id = id, buildBundleElementId = buildBundleElementId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param buildBundleElementId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdDeleteWithHttpInfo(id: kotlin.String, buildBundleElementId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdDeleteRequestConfig(id = id, buildBundleElementId = buildBundleElementId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdDelete
     *
     * @param id 
     * @param buildBundleElementId 
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdDeleteRequestConfig(id: kotlin.String, buildBundleElementId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/customFieldSettings/bundles/build/{id}/values/{buildBundleElementId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"buildBundleElementId"+"}", encodeURIComponent(buildBundleElementId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param buildBundleElementId 
     * @param fields  (optional, default to "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal")
     * @return BuildBundleElement
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdGet(id: kotlin.String, buildBundleElementId: kotlin.String, fields: kotlin.String? = "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal") : BuildBundleElement {
        val localVarResponse = adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdGetWithHttpInfo(id = id, buildBundleElementId = buildBundleElementId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BuildBundleElement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param buildBundleElementId 
     * @param fields  (optional, default to "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal")
     * @return ApiResponse<BuildBundleElement?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdGetWithHttpInfo(id: kotlin.String, buildBundleElementId: kotlin.String, fields: kotlin.String?) : ApiResponse<BuildBundleElement?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdGetRequestConfig(id = id, buildBundleElementId = buildBundleElementId, fields = fields)

        return request<Unit, BuildBundleElement>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdGet
     *
     * @param id 
     * @param buildBundleElementId 
     * @param fields  (optional, default to "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal")
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdGetRequestConfig(id: kotlin.String, buildBundleElementId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/build/{id}/values/{buildBundleElementId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"buildBundleElementId"+"}", encodeURIComponent(buildBundleElementId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param buildBundleElementId 
     * @param fields  (optional, default to "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal")
     * @param buildBundleElement  (optional)
     * @return BuildBundleElement
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdPost(id: kotlin.String, buildBundleElementId: kotlin.String, fields: kotlin.String? = "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal", buildBundleElement: BuildBundleElement? = null) : BuildBundleElement {
        val localVarResponse = adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdPostWithHttpInfo(id = id, buildBundleElementId = buildBundleElementId, fields = fields, buildBundleElement = buildBundleElement)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BuildBundleElement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param buildBundleElementId 
     * @param fields  (optional, default to "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal")
     * @param buildBundleElement  (optional)
     * @return ApiResponse<BuildBundleElement?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdPostWithHttpInfo(id: kotlin.String, buildBundleElementId: kotlin.String, fields: kotlin.String?, buildBundleElement: BuildBundleElement?) : ApiResponse<BuildBundleElement?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdPostRequestConfig(id = id, buildBundleElementId = buildBundleElementId, fields = fields, buildBundleElement = buildBundleElement)

        return request<BuildBundleElement, BuildBundleElement>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdPost
     *
     * @param id 
     * @param buildBundleElementId 
     * @param fields  (optional, default to "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal")
     * @param buildBundleElement  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesBuildIdValuesBuildBundleElementIdPostRequestConfig(id: kotlin.String, buildBundleElementId: kotlin.String, fields: kotlin.String?, buildBundleElement: BuildBundleElement?) : RequestConfig<BuildBundleElement> {
        val localVariableBody = buildBundleElement
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/build/{id}/values/{buildBundleElementId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"buildBundleElementId"+"}", encodeURIComponent(buildBundleElementId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<BuildBundleElement>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesBuildIdValuesGet(id: kotlin.String, fields: kotlin.String? = "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<BuildBundleElement> {
        val localVarResponse = adminCustomFieldSettingsBundlesBuildIdValuesGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BuildBundleElement>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<BuildBundleElement>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesBuildIdValuesGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<BuildBundleElement>?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesBuildIdValuesGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<BuildBundleElement>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesBuildIdValuesGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesBuildIdValuesGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/build/{id}/values".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal")
     * @param buildBundleElement  (optional)
     * @return BuildBundleElement
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesBuildIdValuesPost(id: kotlin.String, fields: kotlin.String? = "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal", buildBundleElement: BuildBundleElement? = null) : BuildBundleElement {
        val localVarResponse = adminCustomFieldSettingsBundlesBuildIdValuesPostWithHttpInfo(id = id, fields = fields, buildBundleElement = buildBundleElement)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BuildBundleElement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal")
     * @param buildBundleElement  (optional)
     * @return ApiResponse<BuildBundleElement?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesBuildIdValuesPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, buildBundleElement: BuildBundleElement?) : ApiResponse<BuildBundleElement?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesBuildIdValuesPostRequestConfig(id = id, fields = fields, buildBundleElement = buildBundleElement)

        return request<BuildBundleElement, BuildBundleElement>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesBuildIdValuesPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,assembleDate,color($type,background,foreground,id),id,name,ordinal")
     * @param buildBundleElement  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesBuildIdValuesPostRequestConfig(id: kotlin.String, fields: kotlin.String?, buildBundleElement: BuildBundleElement?) : RequestConfig<BuildBundleElement> {
        val localVariableBody = buildBundleElement
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/build/{id}/values".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param buildBundle  (optional)
     * @return BuildBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesBuildPost(fields: kotlin.String? = "$type,id", buildBundle: BuildBundle? = null) : BuildBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesBuildPostWithHttpInfo(fields = fields, buildBundle = buildBundle)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BuildBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param buildBundle  (optional)
     * @return ApiResponse<BuildBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesBuildPostWithHttpInfo(fields: kotlin.String?, buildBundle: BuildBundle?) : ApiResponse<BuildBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesBuildPostRequestConfig(fields = fields, buildBundle = buildBundle)

        return request<BuildBundle, BuildBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesBuildPost
     *
     * @param fields  (optional, default to "$type,id")
     * @param buildBundle  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesBuildPostRequestConfig(fields: kotlin.String?, buildBundle: BuildBundle?) : RequestConfig<BuildBundle> {
        val localVariableBody = buildBundle
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/build",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<EnumBundle>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesEnumGet(fields: kotlin.String? = "$type,id", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<EnumBundle> {
        val localVarResponse = adminCustomFieldSettingsBundlesEnumGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<EnumBundle>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<EnumBundle>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesEnumGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<EnumBundle>?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesEnumGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<EnumBundle>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesEnumGet
     *
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesEnumGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/enum",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesEnumIdDelete(id: kotlin.String) : Unit {
        val localVarResponse = adminCustomFieldSettingsBundlesEnumIdDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesEnumIdDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesEnumIdDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesEnumIdDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesEnumIdDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/customFieldSettings/bundles/enum/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return EnumBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesEnumIdGet(id: kotlin.String, fields: kotlin.String? = "$type,id") : EnumBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesEnumIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnumBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return ApiResponse<EnumBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesEnumIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<EnumBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesEnumIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, EnumBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesEnumIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesEnumIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/enum/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param enumBundle  (optional)
     * @return EnumBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesEnumIdPost(id: kotlin.String, fields: kotlin.String? = "$type,id", enumBundle: EnumBundle? = null) : EnumBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesEnumIdPostWithHttpInfo(id = id, fields = fields, enumBundle = enumBundle)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnumBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param enumBundle  (optional)
     * @return ApiResponse<EnumBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesEnumIdPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, enumBundle: EnumBundle?) : ApiResponse<EnumBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesEnumIdPostRequestConfig(id = id, fields = fields, enumBundle = enumBundle)

        return request<EnumBundle, EnumBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesEnumIdPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param enumBundle  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesEnumIdPostRequestConfig(id: kotlin.String, fields: kotlin.String?, enumBundle: EnumBundle?) : RequestConfig<EnumBundle> {
        val localVariableBody = enumBundle
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/enum/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param enumBundleElementId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdDelete(id: kotlin.String, enumBundleElementId: kotlin.String) : Unit {
        val localVarResponse = adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdDeleteWithHttpInfo(id = id, enumBundleElementId = enumBundleElementId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param enumBundleElementId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdDeleteWithHttpInfo(id: kotlin.String, enumBundleElementId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdDeleteRequestConfig(id = id, enumBundleElementId = enumBundleElementId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdDelete
     *
     * @param id 
     * @param enumBundleElementId 
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdDeleteRequestConfig(id: kotlin.String, enumBundleElementId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/customFieldSettings/bundles/enum/{id}/values/{enumBundleElementId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"enumBundleElementId"+"}", encodeURIComponent(enumBundleElementId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param enumBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,localizedName,name,ordinal")
     * @return EnumBundleElement
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdGet(id: kotlin.String, enumBundleElementId: kotlin.String, fields: kotlin.String? = "$type,color($type,background,foreground,id),id,localizedName,name,ordinal") : EnumBundleElement {
        val localVarResponse = adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdGetWithHttpInfo(id = id, enumBundleElementId = enumBundleElementId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnumBundleElement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param enumBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,localizedName,name,ordinal")
     * @return ApiResponse<EnumBundleElement?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdGetWithHttpInfo(id: kotlin.String, enumBundleElementId: kotlin.String, fields: kotlin.String?) : ApiResponse<EnumBundleElement?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdGetRequestConfig(id = id, enumBundleElementId = enumBundleElementId, fields = fields)

        return request<Unit, EnumBundleElement>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdGet
     *
     * @param id 
     * @param enumBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,localizedName,name,ordinal")
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdGetRequestConfig(id: kotlin.String, enumBundleElementId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/enum/{id}/values/{enumBundleElementId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"enumBundleElementId"+"}", encodeURIComponent(enumBundleElementId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param enumBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,localizedName,name,ordinal")
     * @param enumBundleElement  (optional)
     * @return EnumBundleElement
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdPost(id: kotlin.String, enumBundleElementId: kotlin.String, fields: kotlin.String? = "$type,color($type,background,foreground,id),id,localizedName,name,ordinal", enumBundleElement: EnumBundleElement? = null) : EnumBundleElement {
        val localVarResponse = adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdPostWithHttpInfo(id = id, enumBundleElementId = enumBundleElementId, fields = fields, enumBundleElement = enumBundleElement)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnumBundleElement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param enumBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,localizedName,name,ordinal")
     * @param enumBundleElement  (optional)
     * @return ApiResponse<EnumBundleElement?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdPostWithHttpInfo(id: kotlin.String, enumBundleElementId: kotlin.String, fields: kotlin.String?, enumBundleElement: EnumBundleElement?) : ApiResponse<EnumBundleElement?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdPostRequestConfig(id = id, enumBundleElementId = enumBundleElementId, fields = fields, enumBundleElement = enumBundleElement)

        return request<EnumBundleElement, EnumBundleElement>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdPost
     *
     * @param id 
     * @param enumBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,localizedName,name,ordinal")
     * @param enumBundleElement  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesEnumIdValuesEnumBundleElementIdPostRequestConfig(id: kotlin.String, enumBundleElementId: kotlin.String, fields: kotlin.String?, enumBundleElement: EnumBundleElement?) : RequestConfig<EnumBundleElement> {
        val localVariableBody = enumBundleElement
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/enum/{id}/values/{enumBundleElementId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"enumBundleElementId"+"}", encodeURIComponent(enumBundleElementId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,localizedName,name,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<EnumBundleElement>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesEnumIdValuesGet(id: kotlin.String, fields: kotlin.String? = "$type,color($type,background,foreground,id),id,localizedName,name,ordinal", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<EnumBundleElement> {
        val localVarResponse = adminCustomFieldSettingsBundlesEnumIdValuesGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<EnumBundleElement>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,localizedName,name,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<EnumBundleElement>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesEnumIdValuesGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<EnumBundleElement>?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesEnumIdValuesGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<EnumBundleElement>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesEnumIdValuesGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,localizedName,name,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesEnumIdValuesGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/enum/{id}/values".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,localizedName,name,ordinal")
     * @param enumBundleElement  (optional)
     * @return EnumBundleElement
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesEnumIdValuesPost(id: kotlin.String, fields: kotlin.String? = "$type,color($type,background,foreground,id),id,localizedName,name,ordinal", enumBundleElement: EnumBundleElement? = null) : EnumBundleElement {
        val localVarResponse = adminCustomFieldSettingsBundlesEnumIdValuesPostWithHttpInfo(id = id, fields = fields, enumBundleElement = enumBundleElement)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnumBundleElement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,localizedName,name,ordinal")
     * @param enumBundleElement  (optional)
     * @return ApiResponse<EnumBundleElement?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesEnumIdValuesPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, enumBundleElement: EnumBundleElement?) : ApiResponse<EnumBundleElement?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesEnumIdValuesPostRequestConfig(id = id, fields = fields, enumBundleElement = enumBundleElement)

        return request<EnumBundleElement, EnumBundleElement>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesEnumIdValuesPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,localizedName,name,ordinal")
     * @param enumBundleElement  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesEnumIdValuesPostRequestConfig(id: kotlin.String, fields: kotlin.String?, enumBundleElement: EnumBundleElement?) : RequestConfig<EnumBundleElement> {
        val localVariableBody = enumBundleElement
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/enum/{id}/values".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param enumBundle  (optional)
     * @return EnumBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesEnumPost(fields: kotlin.String? = "$type,id", enumBundle: EnumBundle? = null) : EnumBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesEnumPostWithHttpInfo(fields = fields, enumBundle = enumBundle)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnumBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param enumBundle  (optional)
     * @return ApiResponse<EnumBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesEnumPostWithHttpInfo(fields: kotlin.String?, enumBundle: EnumBundle?) : ApiResponse<EnumBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesEnumPostRequestConfig(fields = fields, enumBundle = enumBundle)

        return request<EnumBundle, EnumBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesEnumPost
     *
     * @param fields  (optional, default to "$type,id")
     * @param enumBundle  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesEnumPostRequestConfig(fields: kotlin.String?, enumBundle: EnumBundle?) : RequestConfig<EnumBundle> {
        val localVariableBody = enumBundle
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/enum",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<OwnedBundle>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldGet(fields: kotlin.String? = "$type,id", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<OwnedBundle> {
        val localVarResponse = adminCustomFieldSettingsBundlesOwnedFieldGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<OwnedBundle>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<OwnedBundle>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<OwnedBundle>?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesOwnedFieldGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<OwnedBundle>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesOwnedFieldGet
     *
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesOwnedFieldGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/ownedField",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdDelete(id: kotlin.String) : Unit {
        val localVarResponse = adminCustomFieldSettingsBundlesOwnedFieldIdDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesOwnedFieldIdDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesOwnedFieldIdDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesOwnedFieldIdDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/customFieldSettings/bundles/ownedField/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return OwnedBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdGet(id: kotlin.String, fields: kotlin.String? = "$type,id") : OwnedBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesOwnedFieldIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OwnedBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return ApiResponse<OwnedBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<OwnedBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesOwnedFieldIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, OwnedBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesOwnedFieldIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesOwnedFieldIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/ownedField/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param ownedBundle  (optional)
     * @return OwnedBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdPost(id: kotlin.String, fields: kotlin.String? = "$type,id", ownedBundle: OwnedBundle? = null) : OwnedBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesOwnedFieldIdPostWithHttpInfo(id = id, fields = fields, ownedBundle = ownedBundle)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OwnedBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param ownedBundle  (optional)
     * @return ApiResponse<OwnedBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, ownedBundle: OwnedBundle?) : ApiResponse<OwnedBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesOwnedFieldIdPostRequestConfig(id = id, fields = fields, ownedBundle = ownedBundle)

        return request<OwnedBundle, OwnedBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesOwnedFieldIdPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param ownedBundle  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesOwnedFieldIdPostRequestConfig(id: kotlin.String, fields: kotlin.String?, ownedBundle: OwnedBundle?) : RequestConfig<OwnedBundle> {
        val localVariableBody = ownedBundle
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/ownedField/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<OwnedBundleElement>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdValuesGet(id: kotlin.String, fields: kotlin.String? = "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<OwnedBundleElement> {
        val localVarResponse = adminCustomFieldSettingsBundlesOwnedFieldIdValuesGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<OwnedBundleElement>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<OwnedBundleElement>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdValuesGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<OwnedBundleElement>?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesOwnedFieldIdValuesGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<OwnedBundleElement>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesOwnedFieldIdValuesGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesOwnedFieldIdValuesGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/ownedField/{id}/values".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param ownedBundleElementId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdDelete(id: kotlin.String, ownedBundleElementId: kotlin.String) : Unit {
        val localVarResponse = adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdDeleteWithHttpInfo(id = id, ownedBundleElementId = ownedBundleElementId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param ownedBundleElementId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdDeleteWithHttpInfo(id: kotlin.String, ownedBundleElementId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdDeleteRequestConfig(id = id, ownedBundleElementId = ownedBundleElementId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdDelete
     *
     * @param id 
     * @param ownedBundleElementId 
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdDeleteRequestConfig(id: kotlin.String, ownedBundleElementId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/customFieldSettings/bundles/ownedField/{id}/values/{ownedBundleElementId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"ownedBundleElementId"+"}", encodeURIComponent(ownedBundleElementId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param ownedBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)")
     * @return OwnedBundleElement
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdGet(id: kotlin.String, ownedBundleElementId: kotlin.String, fields: kotlin.String? = "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)") : OwnedBundleElement {
        val localVarResponse = adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdGetWithHttpInfo(id = id, ownedBundleElementId = ownedBundleElementId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OwnedBundleElement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param ownedBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)")
     * @return ApiResponse<OwnedBundleElement?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdGetWithHttpInfo(id: kotlin.String, ownedBundleElementId: kotlin.String, fields: kotlin.String?) : ApiResponse<OwnedBundleElement?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdGetRequestConfig(id = id, ownedBundleElementId = ownedBundleElementId, fields = fields)

        return request<Unit, OwnedBundleElement>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdGet
     *
     * @param id 
     * @param ownedBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)")
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdGetRequestConfig(id: kotlin.String, ownedBundleElementId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/ownedField/{id}/values/{ownedBundleElementId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"ownedBundleElementId"+"}", encodeURIComponent(ownedBundleElementId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param ownedBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)")
     * @param ownedBundleElement  (optional)
     * @return OwnedBundleElement
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdPost(id: kotlin.String, ownedBundleElementId: kotlin.String, fields: kotlin.String? = "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)", ownedBundleElement: OwnedBundleElement? = null) : OwnedBundleElement {
        val localVarResponse = adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdPostWithHttpInfo(id = id, ownedBundleElementId = ownedBundleElementId, fields = fields, ownedBundleElement = ownedBundleElement)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OwnedBundleElement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param ownedBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)")
     * @param ownedBundleElement  (optional)
     * @return ApiResponse<OwnedBundleElement?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdPostWithHttpInfo(id: kotlin.String, ownedBundleElementId: kotlin.String, fields: kotlin.String?, ownedBundleElement: OwnedBundleElement?) : ApiResponse<OwnedBundleElement?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdPostRequestConfig(id = id, ownedBundleElementId = ownedBundleElementId, fields = fields, ownedBundleElement = ownedBundleElement)

        return request<OwnedBundleElement, OwnedBundleElement>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdPost
     *
     * @param id 
     * @param ownedBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)")
     * @param ownedBundleElement  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesOwnedFieldIdValuesOwnedBundleElementIdPostRequestConfig(id: kotlin.String, ownedBundleElementId: kotlin.String, fields: kotlin.String?, ownedBundleElement: OwnedBundleElement?) : RequestConfig<OwnedBundleElement> {
        val localVariableBody = ownedBundleElement
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/ownedField/{id}/values/{ownedBundleElementId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"ownedBundleElementId"+"}", encodeURIComponent(ownedBundleElementId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)")
     * @param ownedBundleElement  (optional)
     * @return OwnedBundleElement
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdValuesPost(id: kotlin.String, fields: kotlin.String? = "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)", ownedBundleElement: OwnedBundleElement? = null) : OwnedBundleElement {
        val localVarResponse = adminCustomFieldSettingsBundlesOwnedFieldIdValuesPostWithHttpInfo(id = id, fields = fields, ownedBundleElement = ownedBundleElement)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OwnedBundleElement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)")
     * @param ownedBundleElement  (optional)
     * @return ApiResponse<OwnedBundleElement?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldIdValuesPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, ownedBundleElement: OwnedBundleElement?) : ApiResponse<OwnedBundleElement?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesOwnedFieldIdValuesPostRequestConfig(id = id, fields = fields, ownedBundleElement = ownedBundleElement)

        return request<OwnedBundleElement, OwnedBundleElement>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesOwnedFieldIdValuesPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,name,ordinal,owner($type,id,login,ringId)")
     * @param ownedBundleElement  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesOwnedFieldIdValuesPostRequestConfig(id: kotlin.String, fields: kotlin.String?, ownedBundleElement: OwnedBundleElement?) : RequestConfig<OwnedBundleElement> {
        val localVariableBody = ownedBundleElement
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/ownedField/{id}/values".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param ownedBundle  (optional)
     * @return OwnedBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldPost(fields: kotlin.String? = "$type,id", ownedBundle: OwnedBundle? = null) : OwnedBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesOwnedFieldPostWithHttpInfo(fields = fields, ownedBundle = ownedBundle)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as OwnedBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param ownedBundle  (optional)
     * @return ApiResponse<OwnedBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesOwnedFieldPostWithHttpInfo(fields: kotlin.String?, ownedBundle: OwnedBundle?) : ApiResponse<OwnedBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesOwnedFieldPostRequestConfig(fields = fields, ownedBundle = ownedBundle)

        return request<OwnedBundle, OwnedBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesOwnedFieldPost
     *
     * @param fields  (optional, default to "$type,id")
     * @param ownedBundle  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesOwnedFieldPostRequestConfig(fields: kotlin.String?, ownedBundle: OwnedBundle?) : RequestConfig<OwnedBundle> {
        val localVariableBody = ownedBundle
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/ownedField",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<StateBundle>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesStateGet(fields: kotlin.String? = "$type,id", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<StateBundle> {
        val localVarResponse = adminCustomFieldSettingsBundlesStateGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<StateBundle>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<StateBundle>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesStateGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<StateBundle>?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesStateGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<StateBundle>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesStateGet
     *
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesStateGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/state",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesStateIdDelete(id: kotlin.String) : Unit {
        val localVarResponse = adminCustomFieldSettingsBundlesStateIdDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesStateIdDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesStateIdDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesStateIdDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesStateIdDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/customFieldSettings/bundles/state/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return StateBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesStateIdGet(id: kotlin.String, fields: kotlin.String? = "$type,id") : StateBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesStateIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StateBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return ApiResponse<StateBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesStateIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<StateBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesStateIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, StateBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesStateIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesStateIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/state/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param stateBundle  (optional)
     * @return StateBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesStateIdPost(id: kotlin.String, fields: kotlin.String? = "$type,id", stateBundle: StateBundle? = null) : StateBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesStateIdPostWithHttpInfo(id = id, fields = fields, stateBundle = stateBundle)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StateBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param stateBundle  (optional)
     * @return ApiResponse<StateBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesStateIdPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, stateBundle: StateBundle?) : ApiResponse<StateBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesStateIdPostRequestConfig(id = id, fields = fields, stateBundle = stateBundle)

        return request<StateBundle, StateBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesStateIdPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param stateBundle  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesStateIdPostRequestConfig(id: kotlin.String, fields: kotlin.String?, stateBundle: StateBundle?) : RequestConfig<StateBundle> {
        val localVariableBody = stateBundle
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/state/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<StateBundleElement>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesStateIdValuesGet(id: kotlin.String, fields: kotlin.String? = "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<StateBundleElement> {
        val localVarResponse = adminCustomFieldSettingsBundlesStateIdValuesGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<StateBundleElement>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<StateBundleElement>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesStateIdValuesGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<StateBundleElement>?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesStateIdValuesGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<StateBundleElement>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesStateIdValuesGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesStateIdValuesGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/state/{id}/values".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal")
     * @param stateBundleElement  (optional)
     * @return StateBundleElement
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesStateIdValuesPost(id: kotlin.String, fields: kotlin.String? = "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal", stateBundleElement: StateBundleElement? = null) : StateBundleElement {
        val localVarResponse = adminCustomFieldSettingsBundlesStateIdValuesPostWithHttpInfo(id = id, fields = fields, stateBundleElement = stateBundleElement)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StateBundleElement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal")
     * @param stateBundleElement  (optional)
     * @return ApiResponse<StateBundleElement?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesStateIdValuesPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, stateBundleElement: StateBundleElement?) : ApiResponse<StateBundleElement?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesStateIdValuesPostRequestConfig(id = id, fields = fields, stateBundleElement = stateBundleElement)

        return request<StateBundleElement, StateBundleElement>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesStateIdValuesPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal")
     * @param stateBundleElement  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesStateIdValuesPostRequestConfig(id: kotlin.String, fields: kotlin.String?, stateBundleElement: StateBundleElement?) : RequestConfig<StateBundleElement> {
        val localVariableBody = stateBundleElement
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/state/{id}/values".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param stateBundleElementId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdDelete(id: kotlin.String, stateBundleElementId: kotlin.String) : Unit {
        val localVarResponse = adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdDeleteWithHttpInfo(id = id, stateBundleElementId = stateBundleElementId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param stateBundleElementId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdDeleteWithHttpInfo(id: kotlin.String, stateBundleElementId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdDeleteRequestConfig(id = id, stateBundleElementId = stateBundleElementId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdDelete
     *
     * @param id 
     * @param stateBundleElementId 
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdDeleteRequestConfig(id: kotlin.String, stateBundleElementId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/customFieldSettings/bundles/state/{id}/values/{stateBundleElementId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"stateBundleElementId"+"}", encodeURIComponent(stateBundleElementId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param stateBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal")
     * @return StateBundleElement
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdGet(id: kotlin.String, stateBundleElementId: kotlin.String, fields: kotlin.String? = "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal") : StateBundleElement {
        val localVarResponse = adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdGetWithHttpInfo(id = id, stateBundleElementId = stateBundleElementId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StateBundleElement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param stateBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal")
     * @return ApiResponse<StateBundleElement?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdGetWithHttpInfo(id: kotlin.String, stateBundleElementId: kotlin.String, fields: kotlin.String?) : ApiResponse<StateBundleElement?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdGetRequestConfig(id = id, stateBundleElementId = stateBundleElementId, fields = fields)

        return request<Unit, StateBundleElement>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdGet
     *
     * @param id 
     * @param stateBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal")
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdGetRequestConfig(id: kotlin.String, stateBundleElementId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/state/{id}/values/{stateBundleElementId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"stateBundleElementId"+"}", encodeURIComponent(stateBundleElementId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param stateBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal")
     * @param stateBundleElement  (optional)
     * @return StateBundleElement
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdPost(id: kotlin.String, stateBundleElementId: kotlin.String, fields: kotlin.String? = "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal", stateBundleElement: StateBundleElement? = null) : StateBundleElement {
        val localVarResponse = adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdPostWithHttpInfo(id = id, stateBundleElementId = stateBundleElementId, fields = fields, stateBundleElement = stateBundleElement)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StateBundleElement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param stateBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal")
     * @param stateBundleElement  (optional)
     * @return ApiResponse<StateBundleElement?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdPostWithHttpInfo(id: kotlin.String, stateBundleElementId: kotlin.String, fields: kotlin.String?, stateBundleElement: StateBundleElement?) : ApiResponse<StateBundleElement?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdPostRequestConfig(id = id, stateBundleElementId = stateBundleElementId, fields = fields, stateBundleElement = stateBundleElement)

        return request<StateBundleElement, StateBundleElement>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdPost
     *
     * @param id 
     * @param stateBundleElementId 
     * @param fields  (optional, default to "$type,color($type,background,foreground,id),id,isResolved,localizedName,name,ordinal")
     * @param stateBundleElement  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesStateIdValuesStateBundleElementIdPostRequestConfig(id: kotlin.String, stateBundleElementId: kotlin.String, fields: kotlin.String?, stateBundleElement: StateBundleElement?) : RequestConfig<StateBundleElement> {
        val localVariableBody = stateBundleElement
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/state/{id}/values/{stateBundleElementId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"stateBundleElementId"+"}", encodeURIComponent(stateBundleElementId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param stateBundle  (optional)
     * @return StateBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesStatePost(fields: kotlin.String? = "$type,id", stateBundle: StateBundle? = null) : StateBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesStatePostWithHttpInfo(fields = fields, stateBundle = stateBundle)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StateBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param stateBundle  (optional)
     * @return ApiResponse<StateBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesStatePostWithHttpInfo(fields: kotlin.String?, stateBundle: StateBundle?) : ApiResponse<StateBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesStatePostRequestConfig(fields = fields, stateBundle = stateBundle)

        return request<StateBundle, StateBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesStatePost
     *
     * @param fields  (optional, default to "$type,id")
     * @param stateBundle  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesStatePostRequestConfig(fields: kotlin.String?, stateBundle: StateBundle?) : RequestConfig<StateBundle> {
        val localVariableBody = stateBundle
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/state",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<UserBundle>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesUserGet(fields: kotlin.String? = "$type,id", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<UserBundle> {
        val localVarResponse = adminCustomFieldSettingsBundlesUserGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UserBundle>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<UserBundle>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesUserGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<UserBundle>?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesUserGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<UserBundle>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesUserGet
     *
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesUserGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/user",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<User>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesUserIdAggregatedUsersGet(id: kotlin.String, fields: kotlin.String? = "$type,banned,email,fullName,guest,id,login,ringId", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<User> {
        val localVarResponse = adminCustomFieldSettingsBundlesUserIdAggregatedUsersGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<User>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<User>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesUserIdAggregatedUsersGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<User>?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesUserIdAggregatedUsersGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<User>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesUserIdAggregatedUsersGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesUserIdAggregatedUsersGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/user/{id}/aggregatedUsers".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesUserIdDelete(id: kotlin.String) : Unit {
        val localVarResponse = adminCustomFieldSettingsBundlesUserIdDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesUserIdDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesUserIdDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesUserIdDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesUserIdDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/customFieldSettings/bundles/user/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return UserBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesUserIdGet(id: kotlin.String, fields: kotlin.String? = "$type,id") : UserBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesUserIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return ApiResponse<UserBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesUserIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<UserBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesUserIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, UserBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesUserIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesUserIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/user/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,allUsersGroup,id,name,ringId")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<UserGroup>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesUserIdGroupsGet(id: kotlin.String, fields: kotlin.String? = "$type,allUsersGroup,id,name,ringId", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<UserGroup> {
        val localVarResponse = adminCustomFieldSettingsBundlesUserIdGroupsGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UserGroup>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,allUsersGroup,id,name,ringId")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<UserGroup>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesUserIdGroupsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<UserGroup>?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesUserIdGroupsGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<UserGroup>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesUserIdGroupsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,allUsersGroup,id,name,ringId")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesUserIdGroupsGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/user/{id}/groups".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,allUsersGroup,id,name,ringId")
     * @param userGroup  (optional)
     * @return UserGroup
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesUserIdGroupsPost(id: kotlin.String, fields: kotlin.String? = "$type,allUsersGroup,id,name,ringId", userGroup: UserGroup? = null) : UserGroup {
        val localVarResponse = adminCustomFieldSettingsBundlesUserIdGroupsPostWithHttpInfo(id = id, fields = fields, userGroup = userGroup)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserGroup
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,allUsersGroup,id,name,ringId")
     * @param userGroup  (optional)
     * @return ApiResponse<UserGroup?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesUserIdGroupsPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, userGroup: UserGroup?) : ApiResponse<UserGroup?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesUserIdGroupsPostRequestConfig(id = id, fields = fields, userGroup = userGroup)

        return request<UserGroup, UserGroup>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesUserIdGroupsPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,allUsersGroup,id,name,ringId")
     * @param userGroup  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesUserIdGroupsPostRequestConfig(id: kotlin.String, fields: kotlin.String?, userGroup: UserGroup?) : RequestConfig<UserGroup> {
        val localVariableBody = userGroup
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/user/{id}/groups".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param userGroupId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesUserIdGroupsUserGroupIdDelete(id: kotlin.String, userGroupId: kotlin.String) : Unit {
        val localVarResponse = adminCustomFieldSettingsBundlesUserIdGroupsUserGroupIdDeleteWithHttpInfo(id = id, userGroupId = userGroupId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param userGroupId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesUserIdGroupsUserGroupIdDeleteWithHttpInfo(id: kotlin.String, userGroupId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesUserIdGroupsUserGroupIdDeleteRequestConfig(id = id, userGroupId = userGroupId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesUserIdGroupsUserGroupIdDelete
     *
     * @param id 
     * @param userGroupId 
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesUserIdGroupsUserGroupIdDeleteRequestConfig(id: kotlin.String, userGroupId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/customFieldSettings/bundles/user/{id}/groups/{userGroupId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"userGroupId"+"}", encodeURIComponent(userGroupId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param userGroupId 
     * @param fields  (optional, default to "$type,allUsersGroup,id,name,ringId")
     * @return UserGroup
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesUserIdGroupsUserGroupIdGet(id: kotlin.String, userGroupId: kotlin.String, fields: kotlin.String? = "$type,allUsersGroup,id,name,ringId") : UserGroup {
        val localVarResponse = adminCustomFieldSettingsBundlesUserIdGroupsUserGroupIdGetWithHttpInfo(id = id, userGroupId = userGroupId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserGroup
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param userGroupId 
     * @param fields  (optional, default to "$type,allUsersGroup,id,name,ringId")
     * @return ApiResponse<UserGroup?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesUserIdGroupsUserGroupIdGetWithHttpInfo(id: kotlin.String, userGroupId: kotlin.String, fields: kotlin.String?) : ApiResponse<UserGroup?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesUserIdGroupsUserGroupIdGetRequestConfig(id = id, userGroupId = userGroupId, fields = fields)

        return request<Unit, UserGroup>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesUserIdGroupsUserGroupIdGet
     *
     * @param id 
     * @param userGroupId 
     * @param fields  (optional, default to "$type,allUsersGroup,id,name,ringId")
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesUserIdGroupsUserGroupIdGetRequestConfig(id: kotlin.String, userGroupId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/user/{id}/groups/{userGroupId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"userGroupId"+"}", encodeURIComponent(userGroupId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<User>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesUserIdIndividualsGet(id: kotlin.String, fields: kotlin.String? = "$type,banned,email,fullName,guest,id,login,ringId", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<User> {
        val localVarResponse = adminCustomFieldSettingsBundlesUserIdIndividualsGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<User>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<User>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesUserIdIndividualsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<User>?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesUserIdIndividualsGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<User>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesUserIdIndividualsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesUserIdIndividualsGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/user/{id}/individuals".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @param user  (optional)
     * @return User
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesUserIdIndividualsPost(id: kotlin.String, fields: kotlin.String? = "$type,banned,email,fullName,guest,id,login,ringId", user: User? = null) : User {
        val localVarResponse = adminCustomFieldSettingsBundlesUserIdIndividualsPostWithHttpInfo(id = id, fields = fields, user = user)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as User
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @param user  (optional)
     * @return ApiResponse<User?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesUserIdIndividualsPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, user: User?) : ApiResponse<User?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesUserIdIndividualsPostRequestConfig(id = id, fields = fields, user = user)

        return request<User, User>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesUserIdIndividualsPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @param user  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesUserIdIndividualsPostRequestConfig(id: kotlin.String, fields: kotlin.String?, user: User?) : RequestConfig<User> {
        val localVariableBody = user
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/user/{id}/individuals".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param userId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesUserIdIndividualsUserIdDelete(id: kotlin.String, userId: kotlin.String) : Unit {
        val localVarResponse = adminCustomFieldSettingsBundlesUserIdIndividualsUserIdDeleteWithHttpInfo(id = id, userId = userId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param userId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesUserIdIndividualsUserIdDeleteWithHttpInfo(id: kotlin.String, userId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesUserIdIndividualsUserIdDeleteRequestConfig(id = id, userId = userId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesUserIdIndividualsUserIdDelete
     *
     * @param id 
     * @param userId 
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesUserIdIndividualsUserIdDeleteRequestConfig(id: kotlin.String, userId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/customFieldSettings/bundles/user/{id}/individuals/{userId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"userId"+"}", encodeURIComponent(userId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param userId 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @return User
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesUserIdIndividualsUserIdGet(id: kotlin.String, userId: kotlin.String, fields: kotlin.String? = "$type,banned,email,fullName,guest,id,login,ringId") : User {
        val localVarResponse = adminCustomFieldSettingsBundlesUserIdIndividualsUserIdGetWithHttpInfo(id = id, userId = userId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as User
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param userId 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @return ApiResponse<User?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesUserIdIndividualsUserIdGetWithHttpInfo(id: kotlin.String, userId: kotlin.String, fields: kotlin.String?) : ApiResponse<User?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesUserIdIndividualsUserIdGetRequestConfig(id = id, userId = userId, fields = fields)

        return request<Unit, User>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesUserIdIndividualsUserIdGet
     *
     * @param id 
     * @param userId 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesUserIdIndividualsUserIdGetRequestConfig(id: kotlin.String, userId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/user/{id}/individuals/{userId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"userId"+"}", encodeURIComponent(userId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param userBundle  (optional)
     * @return UserBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesUserIdPost(id: kotlin.String, fields: kotlin.String? = "$type,id", userBundle: UserBundle? = null) : UserBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesUserIdPostWithHttpInfo(id = id, fields = fields, userBundle = userBundle)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param userBundle  (optional)
     * @return ApiResponse<UserBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesUserIdPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, userBundle: UserBundle?) : ApiResponse<UserBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesUserIdPostRequestConfig(id = id, fields = fields, userBundle = userBundle)

        return request<UserBundle, UserBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesUserIdPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param userBundle  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesUserIdPostRequestConfig(id: kotlin.String, fields: kotlin.String?, userBundle: UserBundle?) : RequestConfig<UserBundle> {
        val localVariableBody = userBundle
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/user/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param userBundle  (optional)
     * @return UserBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesUserPost(fields: kotlin.String? = "$type,id", userBundle: UserBundle? = null) : UserBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesUserPostWithHttpInfo(fields = fields, userBundle = userBundle)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param userBundle  (optional)
     * @return ApiResponse<UserBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesUserPostWithHttpInfo(fields: kotlin.String?, userBundle: UserBundle?) : ApiResponse<UserBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesUserPostRequestConfig(fields = fields, userBundle = userBundle)

        return request<UserBundle, UserBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesUserPost
     *
     * @param fields  (optional, default to "$type,id")
     * @param userBundle  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesUserPostRequestConfig(fields: kotlin.String?, userBundle: UserBundle?) : RequestConfig<UserBundle> {
        val localVariableBody = userBundle
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/user",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<VersionBundle>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesVersionGet(fields: kotlin.String? = "$type,id", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<VersionBundle> {
        val localVarResponse = adminCustomFieldSettingsBundlesVersionGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<VersionBundle>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<VersionBundle>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesVersionGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<VersionBundle>?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesVersionGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<VersionBundle>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesVersionGet
     *
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesVersionGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/version",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesVersionIdDelete(id: kotlin.String) : Unit {
        val localVarResponse = adminCustomFieldSettingsBundlesVersionIdDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesVersionIdDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesVersionIdDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesVersionIdDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesVersionIdDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/customFieldSettings/bundles/version/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return VersionBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesVersionIdGet(id: kotlin.String, fields: kotlin.String? = "$type,id") : VersionBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesVersionIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VersionBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return ApiResponse<VersionBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesVersionIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<VersionBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesVersionIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, VersionBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesVersionIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesVersionIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/version/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param versionBundle  (optional)
     * @return VersionBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesVersionIdPost(id: kotlin.String, fields: kotlin.String? = "$type,id", versionBundle: VersionBundle? = null) : VersionBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesVersionIdPostWithHttpInfo(id = id, fields = fields, versionBundle = versionBundle)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VersionBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param versionBundle  (optional)
     * @return ApiResponse<VersionBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesVersionIdPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, versionBundle: VersionBundle?) : ApiResponse<VersionBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesVersionIdPostRequestConfig(id = id, fields = fields, versionBundle = versionBundle)

        return request<VersionBundle, VersionBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesVersionIdPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param versionBundle  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesVersionIdPostRequestConfig(id: kotlin.String, fields: kotlin.String?, versionBundle: VersionBundle?) : RequestConfig<VersionBundle> {
        val localVariableBody = versionBundle
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/version/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<VersionBundleElement>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesVersionIdValuesGet(id: kotlin.String, fields: kotlin.String? = "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<VersionBundleElement> {
        val localVarResponse = adminCustomFieldSettingsBundlesVersionIdValuesGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<VersionBundleElement>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<VersionBundleElement>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesVersionIdValuesGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<VersionBundleElement>?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesVersionIdValuesGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<VersionBundleElement>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesVersionIdValuesGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesVersionIdValuesGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/version/{id}/values".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released")
     * @param versionBundleElement  (optional)
     * @return VersionBundleElement
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesVersionIdValuesPost(id: kotlin.String, fields: kotlin.String? = "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released", versionBundleElement: VersionBundleElement? = null) : VersionBundleElement {
        val localVarResponse = adminCustomFieldSettingsBundlesVersionIdValuesPostWithHttpInfo(id = id, fields = fields, versionBundleElement = versionBundleElement)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VersionBundleElement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released")
     * @param versionBundleElement  (optional)
     * @return ApiResponse<VersionBundleElement?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesVersionIdValuesPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, versionBundleElement: VersionBundleElement?) : ApiResponse<VersionBundleElement?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesVersionIdValuesPostRequestConfig(id = id, fields = fields, versionBundleElement = versionBundleElement)

        return request<VersionBundleElement, VersionBundleElement>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesVersionIdValuesPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released")
     * @param versionBundleElement  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesVersionIdValuesPostRequestConfig(id: kotlin.String, fields: kotlin.String?, versionBundleElement: VersionBundleElement?) : RequestConfig<VersionBundleElement> {
        val localVariableBody = versionBundleElement
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/version/{id}/values".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param versionBundleElementId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdDelete(id: kotlin.String, versionBundleElementId: kotlin.String) : Unit {
        val localVarResponse = adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdDeleteWithHttpInfo(id = id, versionBundleElementId = versionBundleElementId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param versionBundleElementId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdDeleteWithHttpInfo(id: kotlin.String, versionBundleElementId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdDeleteRequestConfig(id = id, versionBundleElementId = versionBundleElementId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdDelete
     *
     * @param id 
     * @param versionBundleElementId 
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdDeleteRequestConfig(id: kotlin.String, versionBundleElementId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/customFieldSettings/bundles/version/{id}/values/{versionBundleElementId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"versionBundleElementId"+"}", encodeURIComponent(versionBundleElementId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param versionBundleElementId 
     * @param fields  (optional, default to "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released")
     * @return VersionBundleElement
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdGet(id: kotlin.String, versionBundleElementId: kotlin.String, fields: kotlin.String? = "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released") : VersionBundleElement {
        val localVarResponse = adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdGetWithHttpInfo(id = id, versionBundleElementId = versionBundleElementId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VersionBundleElement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param versionBundleElementId 
     * @param fields  (optional, default to "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released")
     * @return ApiResponse<VersionBundleElement?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdGetWithHttpInfo(id: kotlin.String, versionBundleElementId: kotlin.String, fields: kotlin.String?) : ApiResponse<VersionBundleElement?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdGetRequestConfig(id = id, versionBundleElementId = versionBundleElementId, fields = fields)

        return request<Unit, VersionBundleElement>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdGet
     *
     * @param id 
     * @param versionBundleElementId 
     * @param fields  (optional, default to "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released")
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdGetRequestConfig(id: kotlin.String, versionBundleElementId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/bundles/version/{id}/values/{versionBundleElementId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"versionBundleElementId"+"}", encodeURIComponent(versionBundleElementId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param versionBundleElementId 
     * @param fields  (optional, default to "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released")
     * @param versionBundleElement  (optional)
     * @return VersionBundleElement
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdPost(id: kotlin.String, versionBundleElementId: kotlin.String, fields: kotlin.String? = "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released", versionBundleElement: VersionBundleElement? = null) : VersionBundleElement {
        val localVarResponse = adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdPostWithHttpInfo(id = id, versionBundleElementId = versionBundleElementId, fields = fields, versionBundleElement = versionBundleElement)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VersionBundleElement
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param versionBundleElementId 
     * @param fields  (optional, default to "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released")
     * @param versionBundleElement  (optional)
     * @return ApiResponse<VersionBundleElement?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdPostWithHttpInfo(id: kotlin.String, versionBundleElementId: kotlin.String, fields: kotlin.String?, versionBundleElement: VersionBundleElement?) : ApiResponse<VersionBundleElement?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdPostRequestConfig(id = id, versionBundleElementId = versionBundleElementId, fields = fields, versionBundleElement = versionBundleElement)

        return request<VersionBundleElement, VersionBundleElement>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdPost
     *
     * @param id 
     * @param versionBundleElementId 
     * @param fields  (optional, default to "$type,archived,color($type,background,foreground,id),id,name,ordinal,releaseDate,released")
     * @param versionBundleElement  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesVersionIdValuesVersionBundleElementIdPostRequestConfig(id: kotlin.String, versionBundleElementId: kotlin.String, fields: kotlin.String?, versionBundleElement: VersionBundleElement?) : RequestConfig<VersionBundleElement> {
        val localVariableBody = versionBundleElement
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/version/{id}/values/{versionBundleElementId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"versionBundleElementId"+"}", encodeURIComponent(versionBundleElementId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param versionBundle  (optional)
     * @return VersionBundle
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsBundlesVersionPost(fields: kotlin.String? = "$type,id", versionBundle: VersionBundle? = null) : VersionBundle {
        val localVarResponse = adminCustomFieldSettingsBundlesVersionPostWithHttpInfo(fields = fields, versionBundle = versionBundle)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VersionBundle
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param versionBundle  (optional)
     * @return ApiResponse<VersionBundle?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsBundlesVersionPostWithHttpInfo(fields: kotlin.String?, versionBundle: VersionBundle?) : ApiResponse<VersionBundle?> {
        val localVariableConfig = adminCustomFieldSettingsBundlesVersionPostRequestConfig(fields = fields, versionBundle = versionBundle)

        return request<VersionBundle, VersionBundle>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsBundlesVersionPost
     *
     * @param fields  (optional, default to "$type,id")
     * @param versionBundle  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsBundlesVersionPostRequestConfig(fields: kotlin.String?, versionBundle: VersionBundle?) : RequestConfig<VersionBundle> {
        val localVariableBody = versionBundle
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/bundles/version",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<CustomField>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsCustomFieldsGet(fields: kotlin.String? = "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<CustomField> {
        val localVarResponse = adminCustomFieldSettingsCustomFieldsGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<CustomField>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<CustomField>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsCustomFieldsGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<CustomField>?> {
        val localVariableConfig = adminCustomFieldSettingsCustomFieldsGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<CustomField>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsCustomFieldsGet
     *
     * @param fields  (optional, default to "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsCustomFieldsGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/customFields",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsCustomFieldsIdDelete(id: kotlin.String) : Unit {
        val localVarResponse = adminCustomFieldSettingsCustomFieldsIdDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsCustomFieldsIdDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminCustomFieldSettingsCustomFieldsIdDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsCustomFieldsIdDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsCustomFieldsIdDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/customFieldSettings/customFields/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,id,isPublic")
     * @return CustomFieldDefaults
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsCustomFieldsIdFieldDefaultsGet(id: kotlin.String, fields: kotlin.String? = "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,id,isPublic") : CustomFieldDefaults {
        val localVarResponse = adminCustomFieldSettingsCustomFieldsIdFieldDefaultsGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomFieldDefaults
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,id,isPublic")
     * @return ApiResponse<CustomFieldDefaults?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsCustomFieldsIdFieldDefaultsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<CustomFieldDefaults?> {
        val localVariableConfig = adminCustomFieldSettingsCustomFieldsIdFieldDefaultsGetRequestConfig(id = id, fields = fields)

        return request<Unit, CustomFieldDefaults>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsCustomFieldsIdFieldDefaultsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,id,isPublic")
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsCustomFieldsIdFieldDefaultsGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/customFields/{id}/fieldDefaults".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,id,isPublic")
     * @param customFieldDefaults  (optional)
     * @return CustomFieldDefaults
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsCustomFieldsIdFieldDefaultsPost(id: kotlin.String, fields: kotlin.String? = "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,id,isPublic", customFieldDefaults: CustomFieldDefaults? = null) : CustomFieldDefaults {
        val localVarResponse = adminCustomFieldSettingsCustomFieldsIdFieldDefaultsPostWithHttpInfo(id = id, fields = fields, customFieldDefaults = customFieldDefaults)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomFieldDefaults
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,id,isPublic")
     * @param customFieldDefaults  (optional)
     * @return ApiResponse<CustomFieldDefaults?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsCustomFieldsIdFieldDefaultsPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, customFieldDefaults: CustomFieldDefaults?) : ApiResponse<CustomFieldDefaults?> {
        val localVariableConfig = adminCustomFieldSettingsCustomFieldsIdFieldDefaultsPostRequestConfig(id = id, fields = fields, customFieldDefaults = customFieldDefaults)

        return request<CustomFieldDefaults, CustomFieldDefaults>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsCustomFieldsIdFieldDefaultsPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,id,isPublic")
     * @param customFieldDefaults  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsCustomFieldsIdFieldDefaultsPostRequestConfig(id: kotlin.String, fields: kotlin.String?, customFieldDefaults: CustomFieldDefaults?) : RequestConfig<CustomFieldDefaults> {
        val localVariableBody = customFieldDefaults
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/customFields/{id}/fieldDefaults".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal")
     * @return CustomField
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsCustomFieldsIdGet(id: kotlin.String, fields: kotlin.String? = "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal") : CustomField {
        val localVarResponse = adminCustomFieldSettingsCustomFieldsIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomField
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal")
     * @return ApiResponse<CustomField?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsCustomFieldsIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<CustomField?> {
        val localVariableConfig = adminCustomFieldSettingsCustomFieldsIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, CustomField>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsCustomFieldsIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal")
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsCustomFieldsIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/customFields/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<ProjectCustomField>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsCustomFieldsIdInstancesGet(id: kotlin.String, fields: kotlin.String? = "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<ProjectCustomField> {
        val localVarResponse = adminCustomFieldSettingsCustomFieldsIdInstancesGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ProjectCustomField>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<ProjectCustomField>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsCustomFieldsIdInstancesGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<ProjectCustomField>?> {
        val localVariableConfig = adminCustomFieldSettingsCustomFieldsIdInstancesGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<ProjectCustomField>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsCustomFieldsIdInstancesGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsCustomFieldsIdInstancesGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/customFields/{id}/instances".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal")
     * @param customField  (optional)
     * @return CustomField
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsCustomFieldsIdPost(id: kotlin.String, fields: kotlin.String? = "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal", customField: CustomField? = null) : CustomField {
        val localVarResponse = adminCustomFieldSettingsCustomFieldsIdPostWithHttpInfo(id = id, fields = fields, customField = customField)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomField
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal")
     * @param customField  (optional)
     * @return ApiResponse<CustomField?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsCustomFieldsIdPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, customField: CustomField?) : ApiResponse<CustomField?> {
        val localVariableConfig = adminCustomFieldSettingsCustomFieldsIdPostRequestConfig(id = id, fields = fields, customField = customField)

        return request<CustomField, CustomField>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsCustomFieldsIdPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal")
     * @param customField  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsCustomFieldsIdPostRequestConfig(id: kotlin.String, fields: kotlin.String?, customField: CustomField?) : RequestConfig<CustomField> {
        val localVariableBody = customField
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/customFields/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal")
     * @param customField  (optional)
     * @return CustomField
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsCustomFieldsPost(fields: kotlin.String? = "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal", customField: CustomField? = null) : CustomField {
        val localVarResponse = adminCustomFieldSettingsCustomFieldsPostWithHttpInfo(fields = fields, customField = customField)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomField
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal")
     * @param customField  (optional)
     * @return ApiResponse<CustomField?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsCustomFieldsPostWithHttpInfo(fields: kotlin.String?, customField: CustomField?) : ApiResponse<CustomField?> {
        val localVariableConfig = adminCustomFieldSettingsCustomFieldsPostRequestConfig(fields = fields, customField = customField)

        return request<CustomField, CustomField>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsCustomFieldsPost
     *
     * @param fields  (optional, default to "$type,fieldType($type,id),id,isAutoAttached,isUpdateable,localizedName,name,ordinal")
     * @param customField  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsCustomFieldsPostRequestConfig(fields: kotlin.String?, customField: CustomField?) : RequestConfig<CustomField> {
        val localVariableBody = customField
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/customFieldSettings/customFields",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<FieldType>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminCustomFieldSettingsTypesGet(fields: kotlin.String? = "$type,id", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<FieldType> {
        val localVarResponse = adminCustomFieldSettingsTypesGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<FieldType>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<FieldType>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminCustomFieldSettingsTypesGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<FieldType>?> {
        val localVariableConfig = adminCustomFieldSettingsTypesGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<FieldType>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminCustomFieldSettingsTypesGet
     *
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminCustomFieldSettingsTypesGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/customFieldSettings/types",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,creationDate,id,link,name,size")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<BackupFile>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminDatabaseBackupBackupsGet(fields: kotlin.String? = "$type,creationDate,id,link,name,size", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<BackupFile> {
        val localVarResponse = adminDatabaseBackupBackupsGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BackupFile>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,creationDate,id,link,name,size")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<BackupFile>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminDatabaseBackupBackupsGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<BackupFile>?> {
        val localVariableConfig = adminDatabaseBackupBackupsGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<BackupFile>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminDatabaseBackupBackupsGet
     *
     * @param fields  (optional, default to "$type,creationDate,id,link,name,size")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminDatabaseBackupBackupsGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/databaseBackup/backups",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,creationDate,id,link,name,size")
     * @return BackupFile
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminDatabaseBackupBackupsIdGet(id: kotlin.String, fields: kotlin.String? = "$type,creationDate,id,link,name,size") : BackupFile {
        val localVarResponse = adminDatabaseBackupBackupsIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BackupFile
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,creationDate,id,link,name,size")
     * @return ApiResponse<BackupFile?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminDatabaseBackupBackupsIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<BackupFile?> {
        val localVariableConfig = adminDatabaseBackupBackupsIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, BackupFile>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminDatabaseBackupBackupsIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,creationDate,id,link,name,size")
     * @return RequestConfig
     */
    fun adminDatabaseBackupBackupsIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/databaseBackup/backups/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,backupCancelled,backupError($type,date,errorMessage,id),backupInProgress,id")
     * @return BackupStatus
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminDatabaseBackupSettingsBackupStatusGet(fields: kotlin.String? = "$type,backupCancelled,backupError($type,date,errorMessage,id),backupInProgress,id") : BackupStatus {
        val localVarResponse = adminDatabaseBackupSettingsBackupStatusGetWithHttpInfo(fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BackupStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,backupCancelled,backupError($type,date,errorMessage,id),backupInProgress,id")
     * @return ApiResponse<BackupStatus?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminDatabaseBackupSettingsBackupStatusGetWithHttpInfo(fields: kotlin.String?) : ApiResponse<BackupStatus?> {
        val localVariableConfig = adminDatabaseBackupSettingsBackupStatusGetRequestConfig(fields = fields)

        return request<Unit, BackupStatus>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminDatabaseBackupSettingsBackupStatusGet
     *
     * @param fields  (optional, default to "$type,backupCancelled,backupError($type,date,errorMessage,id),backupInProgress,id")
     * @return RequestConfig
     */
    fun adminDatabaseBackupSettingsBackupStatusGetRequestConfig(fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/databaseBackup/settings/backupStatus",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,availableDiskSpace,backupStatus($type,backupCancelled,backupError($type,date,errorMessage,id),backupInProgress,id),id,isOn,location")
     * @return DatabaseBackupSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminDatabaseBackupSettingsGet(fields: kotlin.String? = "$type,availableDiskSpace,backupStatus($type,backupCancelled,backupError($type,date,errorMessage,id),backupInProgress,id),id,isOn,location") : DatabaseBackupSettings {
        val localVarResponse = adminDatabaseBackupSettingsGetWithHttpInfo(fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DatabaseBackupSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,availableDiskSpace,backupStatus($type,backupCancelled,backupError($type,date,errorMessage,id),backupInProgress,id),id,isOn,location")
     * @return ApiResponse<DatabaseBackupSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminDatabaseBackupSettingsGetWithHttpInfo(fields: kotlin.String?) : ApiResponse<DatabaseBackupSettings?> {
        val localVariableConfig = adminDatabaseBackupSettingsGetRequestConfig(fields = fields)

        return request<Unit, DatabaseBackupSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminDatabaseBackupSettingsGet
     *
     * @param fields  (optional, default to "$type,availableDiskSpace,backupStatus($type,backupCancelled,backupError($type,date,errorMessage,id),backupInProgress,id),id,isOn,location")
     * @return RequestConfig
     */
    fun adminDatabaseBackupSettingsGetRequestConfig(fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/databaseBackup/settings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,availableDiskSpace,backupStatus($type,backupCancelled,backupError($type,date,errorMessage,id),backupInProgress,id),id,isOn,location")
     * @param databaseBackupSettings  (optional)
     * @return DatabaseBackupSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminDatabaseBackupSettingsPost(fields: kotlin.String? = "$type,availableDiskSpace,backupStatus($type,backupCancelled,backupError($type,date,errorMessage,id),backupInProgress,id),id,isOn,location", databaseBackupSettings: DatabaseBackupSettings? = null) : DatabaseBackupSettings {
        val localVarResponse = adminDatabaseBackupSettingsPostWithHttpInfo(fields = fields, databaseBackupSettings = databaseBackupSettings)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DatabaseBackupSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,availableDiskSpace,backupStatus($type,backupCancelled,backupError($type,date,errorMessage,id),backupInProgress,id),id,isOn,location")
     * @param databaseBackupSettings  (optional)
     * @return ApiResponse<DatabaseBackupSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminDatabaseBackupSettingsPostWithHttpInfo(fields: kotlin.String?, databaseBackupSettings: DatabaseBackupSettings?) : ApiResponse<DatabaseBackupSettings?> {
        val localVariableConfig = adminDatabaseBackupSettingsPostRequestConfig(fields = fields, databaseBackupSettings = databaseBackupSettings)

        return request<DatabaseBackupSettings, DatabaseBackupSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminDatabaseBackupSettingsPost
     *
     * @param fields  (optional, default to "$type,availableDiskSpace,backupStatus($type,backupCancelled,backupError($type,date,errorMessage,id),backupInProgress,id),id,isOn,location")
     * @param databaseBackupSettings  (optional)
     * @return RequestConfig
     */
    fun adminDatabaseBackupSettingsPostRequestConfig(fields: kotlin.String?, databaseBackupSettings: DatabaseBackupSettings?) : RequestConfig<DatabaseBackupSettings> {
        val localVariableBody = databaseBackupSettings
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/databaseBackup/settings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)")
     * @return AppearanceSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminGlobalSettingsAppearanceSettingsGet(fields: kotlin.String? = "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)") : AppearanceSettings {
        val localVarResponse = adminGlobalSettingsAppearanceSettingsGetWithHttpInfo(fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AppearanceSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)")
     * @return ApiResponse<AppearanceSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminGlobalSettingsAppearanceSettingsGetWithHttpInfo(fields: kotlin.String?) : ApiResponse<AppearanceSettings?> {
        val localVariableConfig = adminGlobalSettingsAppearanceSettingsGetRequestConfig(fields = fields)

        return request<Unit, AppearanceSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminGlobalSettingsAppearanceSettingsGet
     *
     * @param fields  (optional, default to "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)")
     * @return RequestConfig
     */
    fun adminGlobalSettingsAppearanceSettingsGetRequestConfig(fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/globalSettings/appearanceSettings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)")
     * @param appearanceSettings  (optional)
     * @return AppearanceSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminGlobalSettingsAppearanceSettingsPost(fields: kotlin.String? = "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)", appearanceSettings: AppearanceSettings? = null) : AppearanceSettings {
        val localVarResponse = adminGlobalSettingsAppearanceSettingsPostWithHttpInfo(fields = fields, appearanceSettings = appearanceSettings)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AppearanceSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)")
     * @param appearanceSettings  (optional)
     * @return ApiResponse<AppearanceSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminGlobalSettingsAppearanceSettingsPostWithHttpInfo(fields: kotlin.String?, appearanceSettings: AppearanceSettings?) : ApiResponse<AppearanceSettings?> {
        val localVariableConfig = adminGlobalSettingsAppearanceSettingsPostRequestConfig(fields = fields, appearanceSettings = appearanceSettings)

        return request<AppearanceSettings, AppearanceSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminGlobalSettingsAppearanceSettingsPost
     *
     * @param fields  (optional, default to "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)")
     * @param appearanceSettings  (optional)
     * @return RequestConfig
     */
    fun adminGlobalSettingsAppearanceSettingsPostRequestConfig(fields: kotlin.String?, appearanceSettings: AppearanceSettings?) : RequestConfig<AppearanceSettings> {
        val localVariableBody = appearanceSettings
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/globalSettings/appearanceSettings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,appearanceSettings($type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)),id,license($type,error,id,license,username),localeSettings($type,id,isRTL,locale($type,community,id,language,locale,name)),notificationSettings($type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)),restSettings($type,allowAllOrigins,allowedOrigins,id),systemSettings($type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize)")
     * @return GlobalSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminGlobalSettingsGet(fields: kotlin.String? = "$type,appearanceSettings($type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)),id,license($type,error,id,license,username),localeSettings($type,id,isRTL,locale($type,community,id,language,locale,name)),notificationSettings($type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)),restSettings($type,allowAllOrigins,allowedOrigins,id),systemSettings($type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize)") : GlobalSettings {
        val localVarResponse = adminGlobalSettingsGetWithHttpInfo(fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GlobalSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,appearanceSettings($type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)),id,license($type,error,id,license,username),localeSettings($type,id,isRTL,locale($type,community,id,language,locale,name)),notificationSettings($type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)),restSettings($type,allowAllOrigins,allowedOrigins,id),systemSettings($type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize)")
     * @return ApiResponse<GlobalSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminGlobalSettingsGetWithHttpInfo(fields: kotlin.String?) : ApiResponse<GlobalSettings?> {
        val localVariableConfig = adminGlobalSettingsGetRequestConfig(fields = fields)

        return request<Unit, GlobalSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminGlobalSettingsGet
     *
     * @param fields  (optional, default to "$type,appearanceSettings($type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)),id,license($type,error,id,license,username),localeSettings($type,id,isRTL,locale($type,community,id,language,locale,name)),notificationSettings($type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)),restSettings($type,allowAllOrigins,allowedOrigins,id),systemSettings($type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize)")
     * @return RequestConfig
     */
    fun adminGlobalSettingsGetRequestConfig(fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/globalSettings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,error,id,license,username")
     * @return License
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminGlobalSettingsLicenseGet(fields: kotlin.String? = "$type,error,id,license,username") : License {
        val localVarResponse = adminGlobalSettingsLicenseGetWithHttpInfo(fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as License
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,error,id,license,username")
     * @return ApiResponse<License?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminGlobalSettingsLicenseGetWithHttpInfo(fields: kotlin.String?) : ApiResponse<License?> {
        val localVariableConfig = adminGlobalSettingsLicenseGetRequestConfig(fields = fields)

        return request<Unit, License>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminGlobalSettingsLicenseGet
     *
     * @param fields  (optional, default to "$type,error,id,license,username")
     * @return RequestConfig
     */
    fun adminGlobalSettingsLicenseGetRequestConfig(fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/globalSettings/license",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,error,id,license,username")
     * @param license  (optional)
     * @return License
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminGlobalSettingsLicensePost(fields: kotlin.String? = "$type,error,id,license,username", license: License? = null) : License {
        val localVarResponse = adminGlobalSettingsLicensePostWithHttpInfo(fields = fields, license = license)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as License
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,error,id,license,username")
     * @param license  (optional)
     * @return ApiResponse<License?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminGlobalSettingsLicensePostWithHttpInfo(fields: kotlin.String?, license: License?) : ApiResponse<License?> {
        val localVariableConfig = adminGlobalSettingsLicensePostRequestConfig(fields = fields, license = license)

        return request<License, License>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminGlobalSettingsLicensePost
     *
     * @param fields  (optional, default to "$type,error,id,license,username")
     * @param license  (optional)
     * @return RequestConfig
     */
    fun adminGlobalSettingsLicensePostRequestConfig(fields: kotlin.String?, license: License?) : RequestConfig<License> {
        val localVariableBody = license
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/globalSettings/license",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,isRTL,locale($type,community,id,language,locale,name)")
     * @return LocaleSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminGlobalSettingsLocaleSettingsGet(fields: kotlin.String? = "$type,id,isRTL,locale($type,community,id,language,locale,name)") : LocaleSettings {
        val localVarResponse = adminGlobalSettingsLocaleSettingsGetWithHttpInfo(fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LocaleSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,isRTL,locale($type,community,id,language,locale,name)")
     * @return ApiResponse<LocaleSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminGlobalSettingsLocaleSettingsGetWithHttpInfo(fields: kotlin.String?) : ApiResponse<LocaleSettings?> {
        val localVariableConfig = adminGlobalSettingsLocaleSettingsGetRequestConfig(fields = fields)

        return request<Unit, LocaleSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminGlobalSettingsLocaleSettingsGet
     *
     * @param fields  (optional, default to "$type,id,isRTL,locale($type,community,id,language,locale,name)")
     * @return RequestConfig
     */
    fun adminGlobalSettingsLocaleSettingsGetRequestConfig(fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/globalSettings/localeSettings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,isRTL,locale($type,community,id,language,locale,name)")
     * @param localeSettings  (optional)
     * @return LocaleSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminGlobalSettingsLocaleSettingsPost(fields: kotlin.String? = "$type,id,isRTL,locale($type,community,id,language,locale,name)", localeSettings: LocaleSettings? = null) : LocaleSettings {
        val localVarResponse = adminGlobalSettingsLocaleSettingsPostWithHttpInfo(fields = fields, localeSettings = localeSettings)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LocaleSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,isRTL,locale($type,community,id,language,locale,name)")
     * @param localeSettings  (optional)
     * @return ApiResponse<LocaleSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminGlobalSettingsLocaleSettingsPostWithHttpInfo(fields: kotlin.String?, localeSettings: LocaleSettings?) : ApiResponse<LocaleSettings?> {
        val localVariableConfig = adminGlobalSettingsLocaleSettingsPostRequestConfig(fields = fields, localeSettings = localeSettings)

        return request<LocaleSettings, LocaleSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminGlobalSettingsLocaleSettingsPost
     *
     * @param fields  (optional, default to "$type,id,isRTL,locale($type,community,id,language,locale,name)")
     * @param localeSettings  (optional)
     * @return RequestConfig
     */
    fun adminGlobalSettingsLocaleSettingsPostRequestConfig(fields: kotlin.String?, localeSettings: LocaleSettings?) : RequestConfig<LocaleSettings> {
        val localVariableBody = localeSettings
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/globalSettings/localeSettings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)")
     * @return NotificationSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminGlobalSettingsNotificationSettingsGet(fields: kotlin.String? = "$type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)") : NotificationSettings {
        val localVarResponse = adminGlobalSettingsNotificationSettingsGetWithHttpInfo(fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)")
     * @return ApiResponse<NotificationSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminGlobalSettingsNotificationSettingsGetWithHttpInfo(fields: kotlin.String?) : ApiResponse<NotificationSettings?> {
        val localVariableConfig = adminGlobalSettingsNotificationSettingsGetRequestConfig(fields = fields)

        return request<Unit, NotificationSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminGlobalSettingsNotificationSettingsGet
     *
     * @param fields  (optional, default to "$type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)")
     * @return RequestConfig
     */
    fun adminGlobalSettingsNotificationSettingsGetRequestConfig(fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/globalSettings/notificationSettings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)")
     * @param notificationSettings  (optional)
     * @return NotificationSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminGlobalSettingsNotificationSettingsPost(fields: kotlin.String? = "$type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)", notificationSettings: NotificationSettings? = null) : NotificationSettings {
        val localVarResponse = adminGlobalSettingsNotificationSettingsPostWithHttpInfo(fields = fields, notificationSettings = notificationSettings)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)")
     * @param notificationSettings  (optional)
     * @return ApiResponse<NotificationSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminGlobalSettingsNotificationSettingsPostWithHttpInfo(fields: kotlin.String?, notificationSettings: NotificationSettings?) : ApiResponse<NotificationSettings?> {
        val localVariableConfig = adminGlobalSettingsNotificationSettingsPostRequestConfig(fields = fields, notificationSettings = notificationSettings)

        return request<NotificationSettings, NotificationSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminGlobalSettingsNotificationSettingsPost
     *
     * @param fields  (optional, default to "$type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)")
     * @param notificationSettings  (optional)
     * @return RequestConfig
     */
    fun adminGlobalSettingsNotificationSettingsPostRequestConfig(fields: kotlin.String?, notificationSettings: NotificationSettings?) : RequestConfig<NotificationSettings> {
        val localVariableBody = notificationSettings
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/globalSettings/notificationSettings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,appearanceSettings($type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)),id,license($type,error,id,license,username),localeSettings($type,id,isRTL,locale($type,community,id,language,locale,name)),notificationSettings($type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)),restSettings($type,allowAllOrigins,allowedOrigins,id),systemSettings($type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize)")
     * @param globalSettings  (optional)
     * @return GlobalSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminGlobalSettingsPost(fields: kotlin.String? = "$type,appearanceSettings($type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)),id,license($type,error,id,license,username),localeSettings($type,id,isRTL,locale($type,community,id,language,locale,name)),notificationSettings($type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)),restSettings($type,allowAllOrigins,allowedOrigins,id),systemSettings($type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize)", globalSettings: GlobalSettings? = null) : GlobalSettings {
        val localVarResponse = adminGlobalSettingsPostWithHttpInfo(fields = fields, globalSettings = globalSettings)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GlobalSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,appearanceSettings($type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)),id,license($type,error,id,license,username),localeSettings($type,id,isRTL,locale($type,community,id,language,locale,name)),notificationSettings($type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)),restSettings($type,allowAllOrigins,allowedOrigins,id),systemSettings($type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize)")
     * @param globalSettings  (optional)
     * @return ApiResponse<GlobalSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminGlobalSettingsPostWithHttpInfo(fields: kotlin.String?, globalSettings: GlobalSettings?) : ApiResponse<GlobalSettings?> {
        val localVariableConfig = adminGlobalSettingsPostRequestConfig(fields = fields, globalSettings = globalSettings)

        return request<GlobalSettings, GlobalSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminGlobalSettingsPost
     *
     * @param fields  (optional, default to "$type,appearanceSettings($type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,timeZone($type,id,offset,presentation)),id,license($type,error,id,license,username),localeSettings($type,id,isRTL,locale($type,community,id,language,locale,name)),notificationSettings($type,emailSettings($type,id,isEnabled),id,jabberSettings($type,id,isEnabled)),restSettings($type,allowAllOrigins,allowedOrigins,id),systemSettings($type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize)")
     * @param globalSettings  (optional)
     * @return RequestConfig
     */
    fun adminGlobalSettingsPostRequestConfig(fields: kotlin.String?, globalSettings: GlobalSettings?) : RequestConfig<GlobalSettings> {
        val localVariableBody = globalSettings
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/globalSettings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,allowAllOrigins,allowedOrigins,id")
     * @return RestCorsSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminGlobalSettingsRestSettingsGet(fields: kotlin.String? = "$type,allowAllOrigins,allowedOrigins,id") : RestCorsSettings {
        val localVarResponse = adminGlobalSettingsRestSettingsGetWithHttpInfo(fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestCorsSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,allowAllOrigins,allowedOrigins,id")
     * @return ApiResponse<RestCorsSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminGlobalSettingsRestSettingsGetWithHttpInfo(fields: kotlin.String?) : ApiResponse<RestCorsSettings?> {
        val localVariableConfig = adminGlobalSettingsRestSettingsGetRequestConfig(fields = fields)

        return request<Unit, RestCorsSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminGlobalSettingsRestSettingsGet
     *
     * @param fields  (optional, default to "$type,allowAllOrigins,allowedOrigins,id")
     * @return RequestConfig
     */
    fun adminGlobalSettingsRestSettingsGetRequestConfig(fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/globalSettings/restSettings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,allowAllOrigins,allowedOrigins,id")
     * @param restCorsSettings  (optional)
     * @return RestCorsSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminGlobalSettingsRestSettingsPost(fields: kotlin.String? = "$type,allowAllOrigins,allowedOrigins,id", restCorsSettings: RestCorsSettings? = null) : RestCorsSettings {
        val localVarResponse = adminGlobalSettingsRestSettingsPostWithHttpInfo(fields = fields, restCorsSettings = restCorsSettings)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RestCorsSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,allowAllOrigins,allowedOrigins,id")
     * @param restCorsSettings  (optional)
     * @return ApiResponse<RestCorsSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminGlobalSettingsRestSettingsPostWithHttpInfo(fields: kotlin.String?, restCorsSettings: RestCorsSettings?) : ApiResponse<RestCorsSettings?> {
        val localVariableConfig = adminGlobalSettingsRestSettingsPostRequestConfig(fields = fields, restCorsSettings = restCorsSettings)

        return request<RestCorsSettings, RestCorsSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminGlobalSettingsRestSettingsPost
     *
     * @param fields  (optional, default to "$type,allowAllOrigins,allowedOrigins,id")
     * @param restCorsSettings  (optional)
     * @return RequestConfig
     */
    fun adminGlobalSettingsRestSettingsPostRequestConfig(fields: kotlin.String?, restCorsSettings: RestCorsSettings?) : RequestConfig<RestCorsSettings> {
        val localVariableBody = restCorsSettings
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/globalSettings/restSettings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize")
     * @return SystemSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminGlobalSettingsSystemSettingsGet(fields: kotlin.String? = "$type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize") : SystemSettings {
        val localVarResponse = adminGlobalSettingsSystemSettingsGetWithHttpInfo(fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SystemSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize")
     * @return ApiResponse<SystemSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminGlobalSettingsSystemSettingsGetWithHttpInfo(fields: kotlin.String?) : ApiResponse<SystemSettings?> {
        val localVariableConfig = adminGlobalSettingsSystemSettingsGetRequestConfig(fields = fields)

        return request<Unit, SystemSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminGlobalSettingsSystemSettingsGet
     *
     * @param fields  (optional, default to "$type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize")
     * @return RequestConfig
     */
    fun adminGlobalSettingsSystemSettingsGetRequestConfig(fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/globalSettings/systemSettings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize")
     * @param systemSettings  (optional)
     * @return SystemSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminGlobalSettingsSystemSettingsPost(fields: kotlin.String? = "$type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize", systemSettings: SystemSettings? = null) : SystemSettings {
        val localVarResponse = adminGlobalSettingsSystemSettingsPostWithHttpInfo(fields = fields, systemSettings = systemSettings)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SystemSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize")
     * @param systemSettings  (optional)
     * @return ApiResponse<SystemSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminGlobalSettingsSystemSettingsPostWithHttpInfo(fields: kotlin.String?, systemSettings: SystemSettings?) : ApiResponse<SystemSettings?> {
        val localVariableConfig = adminGlobalSettingsSystemSettingsPostRequestConfig(fields = fields, systemSettings = systemSettings)

        return request<SystemSettings, SystemSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminGlobalSettingsSystemSettingsPost
     *
     * @param fields  (optional, default to "$type,baseUrl,id,isApplicationReadOnly,maxExportItems,maxUploadFileSize")
     * @param systemSettings  (optional)
     * @return RequestConfig
     */
    fun adminGlobalSettingsSystemSettingsPostRequestConfig(fields: kotlin.String?, systemSettings: SystemSettings?) : RequestConfig<SystemSettings> {
        val localVariableBody = systemSettings
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/globalSettings/systemSettings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<Project>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsGet(fields: kotlin.String? = "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<Project> {
        val localVarResponse = adminProjectsGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Project>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<Project>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<Project>?> {
        val localVariableConfig = adminProjectsGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<Project>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsGet
     *
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminProjectsGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/projects",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<Article>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdArticlesGet(id: kotlin.String, fields: kotlin.String? = "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<Article> {
        val localVarResponse = adminProjectsIdArticlesGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Article>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<Article>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdArticlesGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<Article>?> {
        val localVariableConfig = adminProjectsIdArticlesGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<Article>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdArticlesGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminProjectsIdArticlesGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/projects/{id}/articles".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<ProjectCustomField>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdCustomFieldsGet(id: kotlin.String, fields: kotlin.String? = "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<ProjectCustomField> {
        val localVarResponse = adminProjectsIdCustomFieldsGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ProjectCustomField>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<ProjectCustomField>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdCustomFieldsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<ProjectCustomField>?> {
        val localVariableConfig = adminProjectsIdCustomFieldsGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<ProjectCustomField>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdCustomFieldsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminProjectsIdCustomFieldsGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/projects/{id}/customFields".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal")
     * @param projectCustomField  (optional)
     * @return ProjectCustomField
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdCustomFieldsPost(id: kotlin.String, fields: kotlin.String? = "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal", projectCustomField: ProjectCustomField? = null) : ProjectCustomField {
        val localVarResponse = adminProjectsIdCustomFieldsPostWithHttpInfo(id = id, fields = fields, projectCustomField = projectCustomField)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProjectCustomField
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal")
     * @param projectCustomField  (optional)
     * @return ApiResponse<ProjectCustomField?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdCustomFieldsPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, projectCustomField: ProjectCustomField?) : ApiResponse<ProjectCustomField?> {
        val localVariableConfig = adminProjectsIdCustomFieldsPostRequestConfig(id = id, fields = fields, projectCustomField = projectCustomField)

        return request<ProjectCustomField, ProjectCustomField>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdCustomFieldsPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal")
     * @param projectCustomField  (optional)
     * @return RequestConfig
     */
    fun adminProjectsIdCustomFieldsPostRequestConfig(id: kotlin.String, fields: kotlin.String?, projectCustomField: ProjectCustomField?) : RequestConfig<ProjectCustomField> {
        val localVariableBody = projectCustomField
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/projects/{id}/customFields".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param projectCustomFieldId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdCustomFieldsProjectCustomFieldIdDelete(id: kotlin.String, projectCustomFieldId: kotlin.String) : Unit {
        val localVarResponse = adminProjectsIdCustomFieldsProjectCustomFieldIdDeleteWithHttpInfo(id = id, projectCustomFieldId = projectCustomFieldId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param projectCustomFieldId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdCustomFieldsProjectCustomFieldIdDeleteWithHttpInfo(id: kotlin.String, projectCustomFieldId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminProjectsIdCustomFieldsProjectCustomFieldIdDeleteRequestConfig(id = id, projectCustomFieldId = projectCustomFieldId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdCustomFieldsProjectCustomFieldIdDelete
     *
     * @param id 
     * @param projectCustomFieldId 
     * @return RequestConfig
     */
    fun adminProjectsIdCustomFieldsProjectCustomFieldIdDeleteRequestConfig(id: kotlin.String, projectCustomFieldId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/projects/{id}/customFields/{projectCustomFieldId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"projectCustomFieldId"+"}", encodeURIComponent(projectCustomFieldId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param projectCustomFieldId 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal")
     * @return ProjectCustomField
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdCustomFieldsProjectCustomFieldIdGet(id: kotlin.String, projectCustomFieldId: kotlin.String, fields: kotlin.String? = "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal") : ProjectCustomField {
        val localVarResponse = adminProjectsIdCustomFieldsProjectCustomFieldIdGetWithHttpInfo(id = id, projectCustomFieldId = projectCustomFieldId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProjectCustomField
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param projectCustomFieldId 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal")
     * @return ApiResponse<ProjectCustomField?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdCustomFieldsProjectCustomFieldIdGetWithHttpInfo(id: kotlin.String, projectCustomFieldId: kotlin.String, fields: kotlin.String?) : ApiResponse<ProjectCustomField?> {
        val localVariableConfig = adminProjectsIdCustomFieldsProjectCustomFieldIdGetRequestConfig(id = id, projectCustomFieldId = projectCustomFieldId, fields = fields)

        return request<Unit, ProjectCustomField>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdCustomFieldsProjectCustomFieldIdGet
     *
     * @param id 
     * @param projectCustomFieldId 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal")
     * @return RequestConfig
     */
    fun adminProjectsIdCustomFieldsProjectCustomFieldIdGetRequestConfig(id: kotlin.String, projectCustomFieldId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/projects/{id}/customFields/{projectCustomFieldId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"projectCustomFieldId"+"}", encodeURIComponent(projectCustomFieldId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param projectCustomFieldId 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal")
     * @param projectCustomField  (optional)
     * @return ProjectCustomField
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdCustomFieldsProjectCustomFieldIdPost(id: kotlin.String, projectCustomFieldId: kotlin.String, fields: kotlin.String? = "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal", projectCustomField: ProjectCustomField? = null) : ProjectCustomField {
        val localVarResponse = adminProjectsIdCustomFieldsProjectCustomFieldIdPostWithHttpInfo(id = id, projectCustomFieldId = projectCustomFieldId, fields = fields, projectCustomField = projectCustomField)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProjectCustomField
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param projectCustomFieldId 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal")
     * @param projectCustomField  (optional)
     * @return ApiResponse<ProjectCustomField?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdCustomFieldsProjectCustomFieldIdPostWithHttpInfo(id: kotlin.String, projectCustomFieldId: kotlin.String, fields: kotlin.String?, projectCustomField: ProjectCustomField?) : ApiResponse<ProjectCustomField?> {
        val localVariableConfig = adminProjectsIdCustomFieldsProjectCustomFieldIdPostRequestConfig(id = id, projectCustomFieldId = projectCustomFieldId, fields = fields, projectCustomField = projectCustomField)

        return request<ProjectCustomField, ProjectCustomField>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdCustomFieldsProjectCustomFieldIdPost
     *
     * @param id 
     * @param projectCustomFieldId 
     * @param fields  (optional, default to "$type,bundle($type,id),canBeEmpty,defaultValues($type,id,name),emptyFieldText,field($type,fieldType($type,id),id,localizedName,name),id,isPublic,ordinal")
     * @param projectCustomField  (optional)
     * @return RequestConfig
     */
    fun adminProjectsIdCustomFieldsProjectCustomFieldIdPostRequestConfig(id: kotlin.String, projectCustomFieldId: kotlin.String, fields: kotlin.String?, projectCustomField: ProjectCustomField?) : RequestConfig<ProjectCustomField> {
        val localVariableBody = projectCustomField
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/projects/{id}/customFields/{projectCustomFieldId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"projectCustomFieldId"+"}", encodeURIComponent(projectCustomFieldId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdDelete(id: kotlin.String) : Unit {
        val localVarResponse = adminProjectsIdDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminProjectsIdDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun adminProjectsIdDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/projects/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @return Project
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdGet(id: kotlin.String, fields: kotlin.String? = "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName") : Project {
        val localVarResponse = adminProjectsIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Project
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @return ApiResponse<Project?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<Project?> {
        val localVariableConfig = adminProjectsIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, Project>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @return RequestConfig
     */
    fun adminProjectsIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/projects/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param customFields &lt;p&gt;The name of the custom field to show in the response. When you use this parameter and request the custom field data in the request URL, the response only shows the requested custom fields instead of all of them.&lt;/p&gt;&lt;p&gt;To show more than one custom field, use this parameter several times.&lt;/p&gt;&lt;p&gt;See Sample 2 for reference.&lt;/p&gt; (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<Issue>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdIssuesGet(id: kotlin.String, customFields: kotlin.String? = null, fields: kotlin.String? = "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<Issue> {
        val localVarResponse = adminProjectsIdIssuesGetWithHttpInfo(id = id, customFields = customFields, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Issue>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param customFields &lt;p&gt;The name of the custom field to show in the response. When you use this parameter and request the custom field data in the request URL, the response only shows the requested custom fields instead of all of them.&lt;/p&gt;&lt;p&gt;To show more than one custom field, use this parameter several times.&lt;/p&gt;&lt;p&gt;See Sample 2 for reference.&lt;/p&gt; (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<Issue>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdIssuesGetWithHttpInfo(id: kotlin.String, customFields: kotlin.String?, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<Issue>?> {
        val localVariableConfig = adminProjectsIdIssuesGetRequestConfig(id = id, customFields = customFields, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<Issue>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdIssuesGet
     *
     * @param id 
     * @param customFields &lt;p&gt;The name of the custom field to show in the response. When you use this parameter and request the custom field data in the request URL, the response only shows the requested custom fields instead of all of them.&lt;/p&gt;&lt;p&gt;To show more than one custom field, use this parameter several times.&lt;/p&gt;&lt;p&gt;See Sample 2 for reference.&lt;/p&gt; (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminProjectsIdIssuesGetRequestConfig(id: kotlin.String, customFields: kotlin.String?, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (customFields != null) {
                    put("customFields", listOf(customFields.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/projects/{id}/issues".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdIssuesIssueIdDelete(id: kotlin.String, issueId: kotlin.String) : Unit {
        val localVarResponse = adminProjectsIdIssuesIssueIdDeleteWithHttpInfo(id = id, issueId = issueId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdIssuesIssueIdDeleteWithHttpInfo(id: kotlin.String, issueId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminProjectsIdIssuesIssueIdDeleteRequestConfig(id = id, issueId = issueId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdIssuesIssueIdDelete
     *
     * @param id 
     * @param issueId 
     * @return RequestConfig
     */
    fun adminProjectsIdIssuesIssueIdDeleteRequestConfig(id: kotlin.String, issueId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/projects/{id}/issues/{issueId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueId"+"}", encodeURIComponent(issueId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueId 
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @return Issue
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdIssuesIssueIdGet(id: kotlin.String, issueId: kotlin.String, fields: kotlin.String? = "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))") : Issue {
        val localVarResponse = adminProjectsIdIssuesIssueIdGetWithHttpInfo(id = id, issueId = issueId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Issue
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueId 
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @return ApiResponse<Issue?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdIssuesIssueIdGetWithHttpInfo(id: kotlin.String, issueId: kotlin.String, fields: kotlin.String?) : ApiResponse<Issue?> {
        val localVariableConfig = adminProjectsIdIssuesIssueIdGetRequestConfig(id = id, issueId = issueId, fields = fields)

        return request<Unit, Issue>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdIssuesIssueIdGet
     *
     * @param id 
     * @param issueId 
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @return RequestConfig
     */
    fun adminProjectsIdIssuesIssueIdGetRequestConfig(id: kotlin.String, issueId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/projects/{id}/issues/{issueId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueId"+"}", encodeURIComponent(issueId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issue  (optional)
     * @return Issue
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdIssuesIssueIdPost(id: kotlin.String, issueId: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))", issue: Issue? = null) : Issue {
        val localVarResponse = adminProjectsIdIssuesIssueIdPostWithHttpInfo(id = id, issueId = issueId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issue = issue)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Issue
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issue  (optional)
     * @return ApiResponse<Issue?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdIssuesIssueIdPostWithHttpInfo(id: kotlin.String, issueId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issue: Issue?) : ApiResponse<Issue?> {
        val localVariableConfig = adminProjectsIdIssuesIssueIdPostRequestConfig(id = id, issueId = issueId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issue = issue)

        return request<Issue, Issue>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdIssuesIssueIdPost
     *
     * @param id 
     * @param issueId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issue  (optional)
     * @return RequestConfig
     */
    fun adminProjectsIdIssuesIssueIdPostRequestConfig(id: kotlin.String, issueId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issue: Issue?) : RequestConfig<Issue> {
        val localVariableBody = issue
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/projects/{id}/issues/{issueId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueId"+"}", encodeURIComponent(issueId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issue  (optional)
     * @return Issue
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdIssuesPost(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))", issue: Issue? = null) : Issue {
        val localVarResponse = adminProjectsIdIssuesPostWithHttpInfo(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issue = issue)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Issue
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issue  (optional)
     * @return ApiResponse<Issue?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdIssuesPostWithHttpInfo(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issue: Issue?) : ApiResponse<Issue?> {
        val localVariableConfig = adminProjectsIdIssuesPostRequestConfig(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issue = issue)

        return request<Issue, Issue>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdIssuesPost
     *
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issue  (optional)
     * @return RequestConfig
     */
    fun adminProjectsIdIssuesPostRequestConfig(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issue: Issue?) : RequestConfig<Issue> {
        val localVariableBody = issue
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/projects/{id}/issues".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @param project  (optional)
     * @return Project
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdPost(id: kotlin.String, fields: kotlin.String? = "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName", project: Project? = null) : Project {
        val localVarResponse = adminProjectsIdPostWithHttpInfo(id = id, fields = fields, project = project)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Project
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @param project  (optional)
     * @return ApiResponse<Project?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, project: Project?) : ApiResponse<Project?> {
        val localVariableConfig = adminProjectsIdPostRequestConfig(id = id, fields = fields, project = project)

        return request<Project, Project>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @param project  (optional)
     * @return RequestConfig
     */
    fun adminProjectsIdPostRequestConfig(id: kotlin.String, fields: kotlin.String?, project: Project?) : RequestConfig<Project> {
        val localVariableBody = project
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/projects/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,enabled,estimate($type,field($type,fieldType($type,id),id,localizedName,name),id),id,timeSpent($type,field($type,fieldType($type,id),id,localizedName,name),id)")
     * @return ProjectTimeTrackingSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdTimeTrackingSettingsGet(id: kotlin.String, fields: kotlin.String? = "$type,enabled,estimate($type,field($type,fieldType($type,id),id,localizedName,name),id),id,timeSpent($type,field($type,fieldType($type,id),id,localizedName,name),id)") : ProjectTimeTrackingSettings {
        val localVarResponse = adminProjectsIdTimeTrackingSettingsGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProjectTimeTrackingSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,enabled,estimate($type,field($type,fieldType($type,id),id,localizedName,name),id),id,timeSpent($type,field($type,fieldType($type,id),id,localizedName,name),id)")
     * @return ApiResponse<ProjectTimeTrackingSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdTimeTrackingSettingsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<ProjectTimeTrackingSettings?> {
        val localVariableConfig = adminProjectsIdTimeTrackingSettingsGetRequestConfig(id = id, fields = fields)

        return request<Unit, ProjectTimeTrackingSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdTimeTrackingSettingsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,enabled,estimate($type,field($type,fieldType($type,id),id,localizedName,name),id),id,timeSpent($type,field($type,fieldType($type,id),id,localizedName,name),id)")
     * @return RequestConfig
     */
    fun adminProjectsIdTimeTrackingSettingsGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/projects/{id}/timeTrackingSettings".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,enabled,estimate($type,field($type,fieldType($type,id),id,localizedName,name),id),id,timeSpent($type,field($type,fieldType($type,id),id,localizedName,name),id)")
     * @param projectTimeTrackingSettings  (optional)
     * @return ProjectTimeTrackingSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdTimeTrackingSettingsPost(id: kotlin.String, fields: kotlin.String? = "$type,enabled,estimate($type,field($type,fieldType($type,id),id,localizedName,name),id),id,timeSpent($type,field($type,fieldType($type,id),id,localizedName,name),id)", projectTimeTrackingSettings: ProjectTimeTrackingSettings? = null) : ProjectTimeTrackingSettings {
        val localVarResponse = adminProjectsIdTimeTrackingSettingsPostWithHttpInfo(id = id, fields = fields, projectTimeTrackingSettings = projectTimeTrackingSettings)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProjectTimeTrackingSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,enabled,estimate($type,field($type,fieldType($type,id),id,localizedName,name),id),id,timeSpent($type,field($type,fieldType($type,id),id,localizedName,name),id)")
     * @param projectTimeTrackingSettings  (optional)
     * @return ApiResponse<ProjectTimeTrackingSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdTimeTrackingSettingsPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, projectTimeTrackingSettings: ProjectTimeTrackingSettings?) : ApiResponse<ProjectTimeTrackingSettings?> {
        val localVariableConfig = adminProjectsIdTimeTrackingSettingsPostRequestConfig(id = id, fields = fields, projectTimeTrackingSettings = projectTimeTrackingSettings)

        return request<ProjectTimeTrackingSettings, ProjectTimeTrackingSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdTimeTrackingSettingsPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,enabled,estimate($type,field($type,fieldType($type,id),id,localizedName,name),id),id,timeSpent($type,field($type,fieldType($type,id),id,localizedName,name),id)")
     * @param projectTimeTrackingSettings  (optional)
     * @return RequestConfig
     */
    fun adminProjectsIdTimeTrackingSettingsPostRequestConfig(id: kotlin.String, fields: kotlin.String?, projectTimeTrackingSettings: ProjectTimeTrackingSettings?) : RequestConfig<ProjectTimeTrackingSettings> {
        val localVariableBody = projectTimeTrackingSettings
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/projects/{id}/timeTrackingSettings".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<WorkItemType>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdTimeTrackingSettingsWorkItemTypesGet(id: kotlin.String, fields: kotlin.String? = "$type,autoAttached,id,name", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<WorkItemType> {
        val localVarResponse = adminProjectsIdTimeTrackingSettingsWorkItemTypesGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WorkItemType>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<WorkItemType>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdTimeTrackingSettingsWorkItemTypesGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<WorkItemType>?> {
        val localVariableConfig = adminProjectsIdTimeTrackingSettingsWorkItemTypesGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<WorkItemType>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdTimeTrackingSettingsWorkItemTypesGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminProjectsIdTimeTrackingSettingsWorkItemTypesGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/projects/{id}/timeTrackingSettings/workItemTypes".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @param workItemType  (optional)
     * @return WorkItemType
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdTimeTrackingSettingsWorkItemTypesPost(id: kotlin.String, fields: kotlin.String? = "$type,autoAttached,id,name", workItemType: WorkItemType? = null) : WorkItemType {
        val localVarResponse = adminProjectsIdTimeTrackingSettingsWorkItemTypesPostWithHttpInfo(id = id, fields = fields, workItemType = workItemType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkItemType
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @param workItemType  (optional)
     * @return ApiResponse<WorkItemType?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdTimeTrackingSettingsWorkItemTypesPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, workItemType: WorkItemType?) : ApiResponse<WorkItemType?> {
        val localVariableConfig = adminProjectsIdTimeTrackingSettingsWorkItemTypesPostRequestConfig(id = id, fields = fields, workItemType = workItemType)

        return request<WorkItemType, WorkItemType>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdTimeTrackingSettingsWorkItemTypesPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @param workItemType  (optional)
     * @return RequestConfig
     */
    fun adminProjectsIdTimeTrackingSettingsWorkItemTypesPostRequestConfig(id: kotlin.String, fields: kotlin.String?, workItemType: WorkItemType?) : RequestConfig<WorkItemType> {
        val localVariableBody = workItemType
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/projects/{id}/timeTrackingSettings/workItemTypes".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param workItemTypeId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdTimeTrackingSettingsWorkItemTypesWorkItemTypeIdDelete(id: kotlin.String, workItemTypeId: kotlin.String) : Unit {
        val localVarResponse = adminProjectsIdTimeTrackingSettingsWorkItemTypesWorkItemTypeIdDeleteWithHttpInfo(id = id, workItemTypeId = workItemTypeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param workItemTypeId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdTimeTrackingSettingsWorkItemTypesWorkItemTypeIdDeleteWithHttpInfo(id: kotlin.String, workItemTypeId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminProjectsIdTimeTrackingSettingsWorkItemTypesWorkItemTypeIdDeleteRequestConfig(id = id, workItemTypeId = workItemTypeId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdTimeTrackingSettingsWorkItemTypesWorkItemTypeIdDelete
     *
     * @param id 
     * @param workItemTypeId 
     * @return RequestConfig
     */
    fun adminProjectsIdTimeTrackingSettingsWorkItemTypesWorkItemTypeIdDeleteRequestConfig(id: kotlin.String, workItemTypeId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/projects/{id}/timeTrackingSettings/workItemTypes/{workItemTypeId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"workItemTypeId"+"}", encodeURIComponent(workItemTypeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param workItemTypeId 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @return WorkItemType
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsIdTimeTrackingSettingsWorkItemTypesWorkItemTypeIdGet(id: kotlin.String, workItemTypeId: kotlin.String, fields: kotlin.String? = "$type,autoAttached,id,name") : WorkItemType {
        val localVarResponse = adminProjectsIdTimeTrackingSettingsWorkItemTypesWorkItemTypeIdGetWithHttpInfo(id = id, workItemTypeId = workItemTypeId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkItemType
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param workItemTypeId 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @return ApiResponse<WorkItemType?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsIdTimeTrackingSettingsWorkItemTypesWorkItemTypeIdGetWithHttpInfo(id: kotlin.String, workItemTypeId: kotlin.String, fields: kotlin.String?) : ApiResponse<WorkItemType?> {
        val localVariableConfig = adminProjectsIdTimeTrackingSettingsWorkItemTypesWorkItemTypeIdGetRequestConfig(id = id, workItemTypeId = workItemTypeId, fields = fields)

        return request<Unit, WorkItemType>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsIdTimeTrackingSettingsWorkItemTypesWorkItemTypeIdGet
     *
     * @param id 
     * @param workItemTypeId 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @return RequestConfig
     */
    fun adminProjectsIdTimeTrackingSettingsWorkItemTypesWorkItemTypeIdGetRequestConfig(id: kotlin.String, workItemTypeId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/projects/{id}/timeTrackingSettings/workItemTypes/{workItemTypeId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"workItemTypeId"+"}", encodeURIComponent(workItemTypeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param template If the &#x60;template&#x60; is not specified, then the new project will use the default settings. &lt;emphasis&gt;Optional&lt;/emphasis&gt;. Lets you specify the template to use for the new project. Possible values: &#x60;scrum&#x60;, &#x60;kanban&#x60;. (optional)
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @param project  (optional)
     * @return Project
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminProjectsPost(template: kotlin.String? = null, fields: kotlin.String? = "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName", project: Project? = null) : Project {
        val localVarResponse = adminProjectsPostWithHttpInfo(template = template, fields = fields, project = project)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Project
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param template If the &#x60;template&#x60; is not specified, then the new project will use the default settings. &lt;emphasis&gt;Optional&lt;/emphasis&gt;. Lets you specify the template to use for the new project. Possible values: &#x60;scrum&#x60;, &#x60;kanban&#x60;. (optional)
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @param project  (optional)
     * @return ApiResponse<Project?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminProjectsPostWithHttpInfo(template: kotlin.String?, fields: kotlin.String?, project: Project?) : ApiResponse<Project?> {
        val localVariableConfig = adminProjectsPostRequestConfig(template = template, fields = fields, project = project)

        return request<Project, Project>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminProjectsPost
     *
     * @param template If the &#x60;template&#x60; is not specified, then the new project will use the default settings. &lt;emphasis&gt;Optional&lt;/emphasis&gt;. Lets you specify the template to use for the new project. Possible values: &#x60;scrum&#x60;, &#x60;kanban&#x60;. (optional)
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @param project  (optional)
     * @return RequestConfig
     */
    fun adminProjectsPostRequestConfig(template: kotlin.String?, fields: kotlin.String?, project: Project?) : RequestConfig<Project> {
        val localVariableBody = project
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (template != null) {
                    put("template", listOf(template.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/projects",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,allocatedMemory,availableMemory,availableProcessors,blobStringsCacheHitRate,cachedResultsCountInDBQueriesCache,databaseBackgroundThreads,databaseLocation,databaseQueriesCacheHitRate,databaseSize,fullDatabaseSize,id,installationFolder,logsLocation,notificationAnalyzerThreads,onlineUsers($type,id,users),pendingAsyncJobs,reportCalculatorThreads,requestsPerSecond,startedTime,textIndexSize,totalTransactions,transactionsPerSecond,uptime,usedMemory")
     * @return Telemetry
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminTelemetryGet(fields: kotlin.String? = "$type,allocatedMemory,availableMemory,availableProcessors,blobStringsCacheHitRate,cachedResultsCountInDBQueriesCache,databaseBackgroundThreads,databaseLocation,databaseQueriesCacheHitRate,databaseSize,fullDatabaseSize,id,installationFolder,logsLocation,notificationAnalyzerThreads,onlineUsers($type,id,users),pendingAsyncJobs,reportCalculatorThreads,requestsPerSecond,startedTime,textIndexSize,totalTransactions,transactionsPerSecond,uptime,usedMemory") : Telemetry {
        val localVarResponse = adminTelemetryGetWithHttpInfo(fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Telemetry
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,allocatedMemory,availableMemory,availableProcessors,blobStringsCacheHitRate,cachedResultsCountInDBQueriesCache,databaseBackgroundThreads,databaseLocation,databaseQueriesCacheHitRate,databaseSize,fullDatabaseSize,id,installationFolder,logsLocation,notificationAnalyzerThreads,onlineUsers($type,id,users),pendingAsyncJobs,reportCalculatorThreads,requestsPerSecond,startedTime,textIndexSize,totalTransactions,transactionsPerSecond,uptime,usedMemory")
     * @return ApiResponse<Telemetry?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminTelemetryGetWithHttpInfo(fields: kotlin.String?) : ApiResponse<Telemetry?> {
        val localVariableConfig = adminTelemetryGetRequestConfig(fields = fields)

        return request<Unit, Telemetry>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTelemetryGet
     *
     * @param fields  (optional, default to "$type,allocatedMemory,availableMemory,availableProcessors,blobStringsCacheHitRate,cachedResultsCountInDBQueriesCache,databaseBackgroundThreads,databaseLocation,databaseQueriesCacheHitRate,databaseSize,fullDatabaseSize,id,installationFolder,logsLocation,notificationAnalyzerThreads,onlineUsers($type,id,users),pendingAsyncJobs,reportCalculatorThreads,requestsPerSecond,startedTime,textIndexSize,totalTransactions,transactionsPerSecond,uptime,usedMemory")
     * @return RequestConfig
     */
    fun adminTelemetryGetRequestConfig(fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/telemetry",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,workItemTypes($type,id,name),workTimeSettings($type,daysAWeek,firstDayOfWeek,id,minutesADay,workDays)")
     * @return GlobalTimeTrackingSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminTimeTrackingSettingsGet(fields: kotlin.String? = "$type,id,workItemTypes($type,id,name),workTimeSettings($type,daysAWeek,firstDayOfWeek,id,minutesADay,workDays)") : GlobalTimeTrackingSettings {
        val localVarResponse = adminTimeTrackingSettingsGetWithHttpInfo(fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GlobalTimeTrackingSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,workItemTypes($type,id,name),workTimeSettings($type,daysAWeek,firstDayOfWeek,id,minutesADay,workDays)")
     * @return ApiResponse<GlobalTimeTrackingSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminTimeTrackingSettingsGetWithHttpInfo(fields: kotlin.String?) : ApiResponse<GlobalTimeTrackingSettings?> {
        val localVariableConfig = adminTimeTrackingSettingsGetRequestConfig(fields = fields)

        return request<Unit, GlobalTimeTrackingSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTimeTrackingSettingsGet
     *
     * @param fields  (optional, default to "$type,id,workItemTypes($type,id,name),workTimeSettings($type,daysAWeek,firstDayOfWeek,id,minutesADay,workDays)")
     * @return RequestConfig
     */
    fun adminTimeTrackingSettingsGetRequestConfig(fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/timeTrackingSettings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<WorkItemType>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminTimeTrackingSettingsWorkItemTypesGet(fields: kotlin.String? = "$type,autoAttached,id,name", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<WorkItemType> {
        val localVarResponse = adminTimeTrackingSettingsWorkItemTypesGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<WorkItemType>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<WorkItemType>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminTimeTrackingSettingsWorkItemTypesGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<WorkItemType>?> {
        val localVariableConfig = adminTimeTrackingSettingsWorkItemTypesGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<WorkItemType>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTimeTrackingSettingsWorkItemTypesGet
     *
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun adminTimeTrackingSettingsWorkItemTypesGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/timeTrackingSettings/workItemTypes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @param workItemType  (optional)
     * @return WorkItemType
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminTimeTrackingSettingsWorkItemTypesPost(fields: kotlin.String? = "$type,autoAttached,id,name", workItemType: WorkItemType? = null) : WorkItemType {
        val localVarResponse = adminTimeTrackingSettingsWorkItemTypesPostWithHttpInfo(fields = fields, workItemType = workItemType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkItemType
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @param workItemType  (optional)
     * @return ApiResponse<WorkItemType?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminTimeTrackingSettingsWorkItemTypesPostWithHttpInfo(fields: kotlin.String?, workItemType: WorkItemType?) : ApiResponse<WorkItemType?> {
        val localVariableConfig = adminTimeTrackingSettingsWorkItemTypesPostRequestConfig(fields = fields, workItemType = workItemType)

        return request<WorkItemType, WorkItemType>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTimeTrackingSettingsWorkItemTypesPost
     *
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @param workItemType  (optional)
     * @return RequestConfig
     */
    fun adminTimeTrackingSettingsWorkItemTypesPostRequestConfig(fields: kotlin.String?, workItemType: WorkItemType?) : RequestConfig<WorkItemType> {
        val localVariableBody = workItemType
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/timeTrackingSettings/workItemTypes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param workItemTypeId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdDelete(workItemTypeId: kotlin.String) : Unit {
        val localVarResponse = adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdDeleteWithHttpInfo(workItemTypeId = workItemTypeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param workItemTypeId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdDeleteWithHttpInfo(workItemTypeId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdDeleteRequestConfig(workItemTypeId = workItemTypeId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdDelete
     *
     * @param workItemTypeId 
     * @return RequestConfig
     */
    fun adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdDeleteRequestConfig(workItemTypeId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/admin/timeTrackingSettings/workItemTypes/{workItemTypeId}".replace("{"+"workItemTypeId"+"}", encodeURIComponent(workItemTypeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param workItemTypeId 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @return WorkItemType
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdGet(workItemTypeId: kotlin.String, fields: kotlin.String? = "$type,autoAttached,id,name") : WorkItemType {
        val localVarResponse = adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdGetWithHttpInfo(workItemTypeId = workItemTypeId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkItemType
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param workItemTypeId 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @return ApiResponse<WorkItemType?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdGetWithHttpInfo(workItemTypeId: kotlin.String, fields: kotlin.String?) : ApiResponse<WorkItemType?> {
        val localVariableConfig = adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdGetRequestConfig(workItemTypeId = workItemTypeId, fields = fields)

        return request<Unit, WorkItemType>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdGet
     *
     * @param workItemTypeId 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @return RequestConfig
     */
    fun adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdGetRequestConfig(workItemTypeId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/timeTrackingSettings/workItemTypes/{workItemTypeId}".replace("{"+"workItemTypeId"+"}", encodeURIComponent(workItemTypeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param workItemTypeId 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @param workItemType  (optional)
     * @return WorkItemType
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdPost(workItemTypeId: kotlin.String, fields: kotlin.String? = "$type,autoAttached,id,name", workItemType: WorkItemType? = null) : WorkItemType {
        val localVarResponse = adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdPostWithHttpInfo(workItemTypeId = workItemTypeId, fields = fields, workItemType = workItemType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkItemType
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param workItemTypeId 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @param workItemType  (optional)
     * @return ApiResponse<WorkItemType?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdPostWithHttpInfo(workItemTypeId: kotlin.String, fields: kotlin.String?, workItemType: WorkItemType?) : ApiResponse<WorkItemType?> {
        val localVariableConfig = adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdPostRequestConfig(workItemTypeId = workItemTypeId, fields = fields, workItemType = workItemType)

        return request<WorkItemType, WorkItemType>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdPost
     *
     * @param workItemTypeId 
     * @param fields  (optional, default to "$type,autoAttached,id,name")
     * @param workItemType  (optional)
     * @return RequestConfig
     */
    fun adminTimeTrackingSettingsWorkItemTypesWorkItemTypeIdPostRequestConfig(workItemTypeId: kotlin.String, fields: kotlin.String?, workItemType: WorkItemType?) : RequestConfig<WorkItemType> {
        val localVariableBody = workItemType
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/timeTrackingSettings/workItemTypes/{workItemTypeId}".replace("{"+"workItemTypeId"+"}", encodeURIComponent(workItemTypeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,daysAWeek,firstDayOfWeek,id,minutesADay,workDays")
     * @return WorkTimeSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminTimeTrackingSettingsWorkTimeSettingsGet(fields: kotlin.String? = "$type,daysAWeek,firstDayOfWeek,id,minutesADay,workDays") : WorkTimeSettings {
        val localVarResponse = adminTimeTrackingSettingsWorkTimeSettingsGetWithHttpInfo(fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkTimeSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,daysAWeek,firstDayOfWeek,id,minutesADay,workDays")
     * @return ApiResponse<WorkTimeSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminTimeTrackingSettingsWorkTimeSettingsGetWithHttpInfo(fields: kotlin.String?) : ApiResponse<WorkTimeSettings?> {
        val localVariableConfig = adminTimeTrackingSettingsWorkTimeSettingsGetRequestConfig(fields = fields)

        return request<Unit, WorkTimeSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTimeTrackingSettingsWorkTimeSettingsGet
     *
     * @param fields  (optional, default to "$type,daysAWeek,firstDayOfWeek,id,minutesADay,workDays")
     * @return RequestConfig
     */
    fun adminTimeTrackingSettingsWorkTimeSettingsGetRequestConfig(fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/admin/timeTrackingSettings/workTimeSettings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,daysAWeek,firstDayOfWeek,id,minutesADay,workDays")
     * @param workTimeSettings  (optional)
     * @return WorkTimeSettings
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun adminTimeTrackingSettingsWorkTimeSettingsPost(fields: kotlin.String? = "$type,daysAWeek,firstDayOfWeek,id,minutesADay,workDays", workTimeSettings: WorkTimeSettings? = null) : WorkTimeSettings {
        val localVarResponse = adminTimeTrackingSettingsWorkTimeSettingsPostWithHttpInfo(fields = fields, workTimeSettings = workTimeSettings)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WorkTimeSettings
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,daysAWeek,firstDayOfWeek,id,minutesADay,workDays")
     * @param workTimeSettings  (optional)
     * @return ApiResponse<WorkTimeSettings?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun adminTimeTrackingSettingsWorkTimeSettingsPostWithHttpInfo(fields: kotlin.String?, workTimeSettings: WorkTimeSettings?) : ApiResponse<WorkTimeSettings?> {
        val localVariableConfig = adminTimeTrackingSettingsWorkTimeSettingsPostRequestConfig(fields = fields, workTimeSettings = workTimeSettings)

        return request<WorkTimeSettings, WorkTimeSettings>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation adminTimeTrackingSettingsWorkTimeSettingsPost
     *
     * @param fields  (optional, default to "$type,daysAWeek,firstDayOfWeek,id,minutesADay,workDays")
     * @param workTimeSettings  (optional)
     * @return RequestConfig
     */
    fun adminTimeTrackingSettingsWorkTimeSettingsPostRequestConfig(fields: kotlin.String?, workTimeSettings: WorkTimeSettings?) : RequestConfig<WorkTimeSettings> {
        val localVariableBody = workTimeSettings
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/admin/timeTrackingSettings/workTimeSettings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<Agile>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun agilesGet(fields: kotlin.String? = "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<Agile> {
        val localVarResponse = agilesGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Agile>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<Agile>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun agilesGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<Agile>?> {
        val localVariableConfig = agilesGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<Agile>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation agilesGet
     *
     * @param fields  (optional, default to "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun agilesGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/agiles",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun agilesIdDelete(id: kotlin.String) : Unit {
        val localVarResponse = agilesIdDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun agilesIdDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = agilesIdDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation agilesIdDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun agilesIdDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/agiles/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))")
     * @return Agile
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun agilesIdGet(id: kotlin.String, fields: kotlin.String? = "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))") : Agile {
        val localVarResponse = agilesIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Agile
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))")
     * @return ApiResponse<Agile?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun agilesIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<Agile?> {
        val localVariableConfig = agilesIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, Agile>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation agilesIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))")
     * @return RequestConfig
     */
    fun agilesIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/agiles/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))")
     * @param agile  (optional)
     * @return Agile
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun agilesIdPost(id: kotlin.String, fields: kotlin.String? = "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))", agile: Agile? = null) : Agile {
        val localVarResponse = agilesIdPostWithHttpInfo(id = id, fields = fields, agile = agile)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Agile
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))")
     * @param agile  (optional)
     * @return ApiResponse<Agile?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun agilesIdPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, agile: Agile?) : ApiResponse<Agile?> {
        val localVariableConfig = agilesIdPostRequestConfig(id = id, fields = fields, agile = agile)

        return request<Agile, Agile>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation agilesIdPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))")
     * @param agile  (optional)
     * @return RequestConfig
     */
    fun agilesIdPostRequestConfig(id: kotlin.String, fields: kotlin.String?, agile: Agile?) : RequestConfig<Agile> {
        val localVariableBody = agile
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/agiles/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,archived,finish,id,isDefault,name,start")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<Sprint>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun agilesIdSprintsGet(id: kotlin.String, fields: kotlin.String? = "$type,archived,finish,id,isDefault,name,start", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<Sprint> {
        val localVarResponse = agilesIdSprintsGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Sprint>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,archived,finish,id,isDefault,name,start")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<Sprint>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun agilesIdSprintsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<Sprint>?> {
        val localVariableConfig = agilesIdSprintsGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<Sprint>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation agilesIdSprintsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,archived,finish,id,isDefault,name,start")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun agilesIdSprintsGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/agiles/{id}/sprints".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,archived,finish,id,isDefault,name,start")
     * @param sprint  (optional)
     * @return Sprint
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun agilesIdSprintsPost(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,archived,finish,id,isDefault,name,start", sprint: Sprint? = null) : Sprint {
        val localVarResponse = agilesIdSprintsPostWithHttpInfo(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, sprint = sprint)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Sprint
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,archived,finish,id,isDefault,name,start")
     * @param sprint  (optional)
     * @return ApiResponse<Sprint?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun agilesIdSprintsPostWithHttpInfo(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, sprint: Sprint?) : ApiResponse<Sprint?> {
        val localVariableConfig = agilesIdSprintsPostRequestConfig(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, sprint = sprint)

        return request<Sprint, Sprint>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation agilesIdSprintsPost
     *
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,archived,finish,id,isDefault,name,start")
     * @param sprint  (optional)
     * @return RequestConfig
     */
    fun agilesIdSprintsPostRequestConfig(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, sprint: Sprint?) : RequestConfig<Sprint> {
        val localVariableBody = sprint
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/agiles/{id}/sprints".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param sprintId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun agilesIdSprintsSprintIdDelete(id: kotlin.String, sprintId: kotlin.String) : Unit {
        val localVarResponse = agilesIdSprintsSprintIdDeleteWithHttpInfo(id = id, sprintId = sprintId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param sprintId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun agilesIdSprintsSprintIdDeleteWithHttpInfo(id: kotlin.String, sprintId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = agilesIdSprintsSprintIdDeleteRequestConfig(id = id, sprintId = sprintId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation agilesIdSprintsSprintIdDelete
     *
     * @param id 
     * @param sprintId 
     * @return RequestConfig
     */
    fun agilesIdSprintsSprintIdDeleteRequestConfig(id: kotlin.String, sprintId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/agiles/{id}/sprints/{sprintId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"sprintId"+"}", encodeURIComponent(sprintId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param sprintId 
     * @param fields  (optional, default to "$type,archived,finish,id,isDefault,name,start")
     * @return Sprint
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun agilesIdSprintsSprintIdGet(id: kotlin.String, sprintId: kotlin.String, fields: kotlin.String? = "$type,archived,finish,id,isDefault,name,start") : Sprint {
        val localVarResponse = agilesIdSprintsSprintIdGetWithHttpInfo(id = id, sprintId = sprintId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Sprint
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param sprintId 
     * @param fields  (optional, default to "$type,archived,finish,id,isDefault,name,start")
     * @return ApiResponse<Sprint?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun agilesIdSprintsSprintIdGetWithHttpInfo(id: kotlin.String, sprintId: kotlin.String, fields: kotlin.String?) : ApiResponse<Sprint?> {
        val localVariableConfig = agilesIdSprintsSprintIdGetRequestConfig(id = id, sprintId = sprintId, fields = fields)

        return request<Unit, Sprint>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation agilesIdSprintsSprintIdGet
     *
     * @param id 
     * @param sprintId 
     * @param fields  (optional, default to "$type,archived,finish,id,isDefault,name,start")
     * @return RequestConfig
     */
    fun agilesIdSprintsSprintIdGetRequestConfig(id: kotlin.String, sprintId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/agiles/{id}/sprints/{sprintId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"sprintId"+"}", encodeURIComponent(sprintId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param sprintId 
     * @param fields  (optional, default to "$type,archived,finish,id,isDefault,name,start")
     * @param sprint  (optional)
     * @return Sprint
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun agilesIdSprintsSprintIdPost(id: kotlin.String, sprintId: kotlin.String, fields: kotlin.String? = "$type,archived,finish,id,isDefault,name,start", sprint: Sprint? = null) : Sprint {
        val localVarResponse = agilesIdSprintsSprintIdPostWithHttpInfo(id = id, sprintId = sprintId, fields = fields, sprint = sprint)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Sprint
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param sprintId 
     * @param fields  (optional, default to "$type,archived,finish,id,isDefault,name,start")
     * @param sprint  (optional)
     * @return ApiResponse<Sprint?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun agilesIdSprintsSprintIdPostWithHttpInfo(id: kotlin.String, sprintId: kotlin.String, fields: kotlin.String?, sprint: Sprint?) : ApiResponse<Sprint?> {
        val localVariableConfig = agilesIdSprintsSprintIdPostRequestConfig(id = id, sprintId = sprintId, fields = fields, sprint = sprint)

        return request<Sprint, Sprint>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation agilesIdSprintsSprintIdPost
     *
     * @param id 
     * @param sprintId 
     * @param fields  (optional, default to "$type,archived,finish,id,isDefault,name,start")
     * @param sprint  (optional)
     * @return RequestConfig
     */
    fun agilesIdSprintsSprintIdPostRequestConfig(id: kotlin.String, sprintId: kotlin.String, fields: kotlin.String?, sprint: Sprint?) : RequestConfig<Sprint> {
        val localVariableBody = sprint
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/agiles/{id}/sprints/{sprintId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"sprintId"+"}", encodeURIComponent(sprintId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param template The name of the board template that should be used. Possible values: &#x60;kanban&#x60;, &#x60;scrum&#x60;, &#x60;version&#x60;, &#x60;custom&#x60;, &#x60;personal&#x60;. (optional)
     * @param fields  (optional, default to "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))")
     * @param agile  (optional)
     * @return Agile
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun agilesPost(template: kotlin.String? = null, fields: kotlin.String? = "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))", agile: Agile? = null) : Agile {
        val localVarResponse = agilesPostWithHttpInfo(template = template, fields = fields, agile = agile)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Agile
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param template The name of the board template that should be used. Possible values: &#x60;kanban&#x60;, &#x60;scrum&#x60;, &#x60;version&#x60;, &#x60;custom&#x60;, &#x60;personal&#x60;. (optional)
     * @param fields  (optional, default to "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))")
     * @param agile  (optional)
     * @return ApiResponse<Agile?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun agilesPostWithHttpInfo(template: kotlin.String?, fields: kotlin.String?, agile: Agile?) : ApiResponse<Agile?> {
        val localVariableConfig = agilesPostRequestConfig(template = template, fields = fields, agile = agile)

        return request<Agile, Agile>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation agilesPost
     *
     * @param template The name of the board template that should be used. Possible values: &#x60;kanban&#x60;, &#x60;scrum&#x60;, &#x60;version&#x60;, &#x60;custom&#x60;, &#x60;personal&#x60;. (optional)
     * @param fields  (optional, default to "$type,columnSettings($type,columns($type,id),field($type,fieldType($type,id),id,localizedName,name),id),id,name,owner($type,id,login,ringId),projects($type,id,name,shortName),status($type,id,valid),swimlaneSettings($type,enabled,field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,values($type,id,name))")
     * @param agile  (optional)
     * @return RequestConfig
     */
    fun agilesPostRequestConfig(template: kotlin.String?, fields: kotlin.String?, agile: Agile?) : RequestConfig<Agile> {
        val localVariableBody = agile
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (template != null) {
                    put("template", listOf(template.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/agiles",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<Article>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesGet(fields: kotlin.String? = "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<Article> {
        val localVarResponse = articlesGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Article>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<Article>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<Article>?> {
        val localVariableConfig = articlesGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<Article>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesGet
     *
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun articlesGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/articles",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param articleAttachmentId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdAttachmentsArticleAttachmentIdDelete(id: kotlin.String, articleAttachmentId: kotlin.String) : Unit {
        val localVarResponse = articlesIdAttachmentsArticleAttachmentIdDeleteWithHttpInfo(id = id, articleAttachmentId = articleAttachmentId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param articleAttachmentId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdAttachmentsArticleAttachmentIdDeleteWithHttpInfo(id: kotlin.String, articleAttachmentId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = articlesIdAttachmentsArticleAttachmentIdDeleteRequestConfig(id = id, articleAttachmentId = articleAttachmentId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdAttachmentsArticleAttachmentIdDelete
     *
     * @param id 
     * @param articleAttachmentId 
     * @return RequestConfig
     */
    fun articlesIdAttachmentsArticleAttachmentIdDeleteRequestConfig(id: kotlin.String, articleAttachmentId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/articles/{id}/attachments/{articleAttachmentId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"articleAttachmentId"+"}", encodeURIComponent(articleAttachmentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param articleAttachmentId 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @return ArticleAttachment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdAttachmentsArticleAttachmentIdGet(id: kotlin.String, articleAttachmentId: kotlin.String, fields: kotlin.String? = "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url") : ArticleAttachment {
        val localVarResponse = articlesIdAttachmentsArticleAttachmentIdGetWithHttpInfo(id = id, articleAttachmentId = articleAttachmentId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ArticleAttachment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param articleAttachmentId 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @return ApiResponse<ArticleAttachment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdAttachmentsArticleAttachmentIdGetWithHttpInfo(id: kotlin.String, articleAttachmentId: kotlin.String, fields: kotlin.String?) : ApiResponse<ArticleAttachment?> {
        val localVariableConfig = articlesIdAttachmentsArticleAttachmentIdGetRequestConfig(id = id, articleAttachmentId = articleAttachmentId, fields = fields)

        return request<Unit, ArticleAttachment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdAttachmentsArticleAttachmentIdGet
     *
     * @param id 
     * @param articleAttachmentId 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @return RequestConfig
     */
    fun articlesIdAttachmentsArticleAttachmentIdGetRequestConfig(id: kotlin.String, articleAttachmentId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/articles/{id}/attachments/{articleAttachmentId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"articleAttachmentId"+"}", encodeURIComponent(articleAttachmentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param articleAttachmentId 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param articleAttachment  (optional)
     * @return ArticleAttachment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdAttachmentsArticleAttachmentIdPost(id: kotlin.String, articleAttachmentId: kotlin.String, fields: kotlin.String? = "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url", articleAttachment: ArticleAttachment? = null) : ArticleAttachment {
        val localVarResponse = articlesIdAttachmentsArticleAttachmentIdPostWithHttpInfo(id = id, articleAttachmentId = articleAttachmentId, fields = fields, articleAttachment = articleAttachment)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ArticleAttachment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param articleAttachmentId 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param articleAttachment  (optional)
     * @return ApiResponse<ArticleAttachment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdAttachmentsArticleAttachmentIdPostWithHttpInfo(id: kotlin.String, articleAttachmentId: kotlin.String, fields: kotlin.String?, articleAttachment: ArticleAttachment?) : ApiResponse<ArticleAttachment?> {
        val localVariableConfig = articlesIdAttachmentsArticleAttachmentIdPostRequestConfig(id = id, articleAttachmentId = articleAttachmentId, fields = fields, articleAttachment = articleAttachment)

        return request<ArticleAttachment, ArticleAttachment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdAttachmentsArticleAttachmentIdPost
     *
     * @param id 
     * @param articleAttachmentId 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param articleAttachment  (optional)
     * @return RequestConfig
     */
    fun articlesIdAttachmentsArticleAttachmentIdPostRequestConfig(id: kotlin.String, articleAttachmentId: kotlin.String, fields: kotlin.String?, articleAttachment: ArticleAttachment?) : RequestConfig<ArticleAttachment> {
        val localVariableBody = articleAttachment
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/articles/{id}/attachments/{articleAttachmentId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"articleAttachmentId"+"}", encodeURIComponent(articleAttachmentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<ArticleAttachment>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdAttachmentsGet(id: kotlin.String, fields: kotlin.String? = "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<ArticleAttachment> {
        val localVarResponse = articlesIdAttachmentsGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ArticleAttachment>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<ArticleAttachment>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdAttachmentsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<ArticleAttachment>?> {
        val localVariableConfig = articlesIdAttachmentsGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<ArticleAttachment>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdAttachmentsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun articlesIdAttachmentsGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/articles/{id}/attachments".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param articleAttachment  (optional)
     * @return ArticleAttachment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdAttachmentsPost(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url", articleAttachment: ArticleAttachment? = null) : ArticleAttachment {
        val localVarResponse = articlesIdAttachmentsPostWithHttpInfo(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, articleAttachment = articleAttachment)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ArticleAttachment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param articleAttachment  (optional)
     * @return ApiResponse<ArticleAttachment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdAttachmentsPostWithHttpInfo(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, articleAttachment: ArticleAttachment?) : ApiResponse<ArticleAttachment?> {
        val localVariableConfig = articlesIdAttachmentsPostRequestConfig(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, articleAttachment = articleAttachment)

        return request<ArticleAttachment, ArticleAttachment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdAttachmentsPost
     *
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param articleAttachment  (optional)
     * @return RequestConfig
     */
    fun articlesIdAttachmentsPostRequestConfig(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, articleAttachment: ArticleAttachment?) : RequestConfig<ArticleAttachment> {
        val localVariableBody = articleAttachment
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/articles/{id}/attachments".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param articleId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdChildArticlesArticleIdDelete(id: kotlin.String, articleId: kotlin.String) : Unit {
        val localVarResponse = articlesIdChildArticlesArticleIdDeleteWithHttpInfo(id = id, articleId = articleId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param articleId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdChildArticlesArticleIdDeleteWithHttpInfo(id: kotlin.String, articleId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = articlesIdChildArticlesArticleIdDeleteRequestConfig(id = id, articleId = articleId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdChildArticlesArticleIdDelete
     *
     * @param id 
     * @param articleId 
     * @return RequestConfig
     */
    fun articlesIdChildArticlesArticleIdDeleteRequestConfig(id: kotlin.String, articleId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/articles/{id}/childArticles/{articleId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"articleId"+"}", encodeURIComponent(articleId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param articleId 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @return Article
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdChildArticlesArticleIdGet(id: kotlin.String, articleId: kotlin.String, fields: kotlin.String? = "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)") : Article {
        val localVarResponse = articlesIdChildArticlesArticleIdGetWithHttpInfo(id = id, articleId = articleId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Article
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param articleId 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @return ApiResponse<Article?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdChildArticlesArticleIdGetWithHttpInfo(id: kotlin.String, articleId: kotlin.String, fields: kotlin.String?) : ApiResponse<Article?> {
        val localVariableConfig = articlesIdChildArticlesArticleIdGetRequestConfig(id = id, articleId = articleId, fields = fields)

        return request<Unit, Article>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdChildArticlesArticleIdGet
     *
     * @param id 
     * @param articleId 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @return RequestConfig
     */
    fun articlesIdChildArticlesArticleIdGetRequestConfig(id: kotlin.String, articleId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/articles/{id}/childArticles/{articleId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"articleId"+"}", encodeURIComponent(articleId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param articleId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires Apply Commands Silently permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param article  (optional)
     * @return Article
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdChildArticlesArticleIdPost(id: kotlin.String, articleId: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)", article: Article? = null) : Article {
        val localVarResponse = articlesIdChildArticlesArticleIdPostWithHttpInfo(id = id, articleId = articleId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, article = article)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Article
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param articleId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires Apply Commands Silently permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param article  (optional)
     * @return ApiResponse<Article?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdChildArticlesArticleIdPostWithHttpInfo(id: kotlin.String, articleId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, article: Article?) : ApiResponse<Article?> {
        val localVariableConfig = articlesIdChildArticlesArticleIdPostRequestConfig(id = id, articleId = articleId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, article = article)

        return request<Article, Article>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdChildArticlesArticleIdPost
     *
     * @param id 
     * @param articleId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires Apply Commands Silently permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param article  (optional)
     * @return RequestConfig
     */
    fun articlesIdChildArticlesArticleIdPostRequestConfig(id: kotlin.String, articleId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, article: Article?) : RequestConfig<Article> {
        val localVariableBody = article
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/articles/{id}/childArticles/{articleId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"articleId"+"}", encodeURIComponent(articleId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<Article>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdChildArticlesGet(id: kotlin.String, fields: kotlin.String? = "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<Article> {
        val localVarResponse = articlesIdChildArticlesGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Article>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<Article>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdChildArticlesGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<Article>?> {
        val localVariableConfig = articlesIdChildArticlesGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<Article>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdChildArticlesGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun articlesIdChildArticlesGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/articles/{id}/childArticles".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires Apply Commands Silently permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param article  (optional)
     * @return Article
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdChildArticlesPost(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)", article: Article? = null) : Article {
        val localVarResponse = articlesIdChildArticlesPostWithHttpInfo(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, article = article)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Article
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires Apply Commands Silently permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param article  (optional)
     * @return ApiResponse<Article?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdChildArticlesPostWithHttpInfo(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, article: Article?) : ApiResponse<Article?> {
        val localVariableConfig = articlesIdChildArticlesPostRequestConfig(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, article = article)

        return request<Article, Article>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdChildArticlesPost
     *
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires Apply Commands Silently permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param article  (optional)
     * @return RequestConfig
     */
    fun articlesIdChildArticlesPostRequestConfig(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, article: Article?) : RequestConfig<Article> {
        val localVariableBody = article
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/articles/{id}/childArticles".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param articleCommentId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdCommentsArticleCommentIdDelete(id: kotlin.String, articleCommentId: kotlin.String) : Unit {
        val localVarResponse = articlesIdCommentsArticleCommentIdDeleteWithHttpInfo(id = id, articleCommentId = articleCommentId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param articleCommentId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdCommentsArticleCommentIdDeleteWithHttpInfo(id: kotlin.String, articleCommentId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = articlesIdCommentsArticleCommentIdDeleteRequestConfig(id = id, articleCommentId = articleCommentId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdCommentsArticleCommentIdDelete
     *
     * @param id 
     * @param articleCommentId 
     * @return RequestConfig
     */
    fun articlesIdCommentsArticleCommentIdDeleteRequestConfig(id: kotlin.String, articleCommentId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/articles/{id}/comments/{articleCommentId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"articleCommentId"+"}", encodeURIComponent(articleCommentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param articleCommentId 
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @return ArticleComment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdCommentsArticleCommentIdGet(id: kotlin.String, articleCommentId: kotlin.String, fields: kotlin.String? = "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))") : ArticleComment {
        val localVarResponse = articlesIdCommentsArticleCommentIdGetWithHttpInfo(id = id, articleCommentId = articleCommentId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ArticleComment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param articleCommentId 
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @return ApiResponse<ArticleComment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdCommentsArticleCommentIdGetWithHttpInfo(id: kotlin.String, articleCommentId: kotlin.String, fields: kotlin.String?) : ApiResponse<ArticleComment?> {
        val localVariableConfig = articlesIdCommentsArticleCommentIdGetRequestConfig(id = id, articleCommentId = articleCommentId, fields = fields)

        return request<Unit, ArticleComment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdCommentsArticleCommentIdGet
     *
     * @param id 
     * @param articleCommentId 
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @return RequestConfig
     */
    fun articlesIdCommentsArticleCommentIdGetRequestConfig(id: kotlin.String, articleCommentId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/articles/{id}/comments/{articleCommentId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"articleCommentId"+"}", encodeURIComponent(articleCommentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param articleCommentId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param articleComment  (optional)
     * @return ArticleComment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdCommentsArticleCommentIdPost(id: kotlin.String, articleCommentId: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))", articleComment: ArticleComment? = null) : ArticleComment {
        val localVarResponse = articlesIdCommentsArticleCommentIdPostWithHttpInfo(id = id, articleCommentId = articleCommentId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, articleComment = articleComment)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ArticleComment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param articleCommentId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param articleComment  (optional)
     * @return ApiResponse<ArticleComment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdCommentsArticleCommentIdPostWithHttpInfo(id: kotlin.String, articleCommentId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, articleComment: ArticleComment?) : ApiResponse<ArticleComment?> {
        val localVariableConfig = articlesIdCommentsArticleCommentIdPostRequestConfig(id = id, articleCommentId = articleCommentId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, articleComment = articleComment)

        return request<ArticleComment, ArticleComment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdCommentsArticleCommentIdPost
     *
     * @param id 
     * @param articleCommentId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param articleComment  (optional)
     * @return RequestConfig
     */
    fun articlesIdCommentsArticleCommentIdPostRequestConfig(id: kotlin.String, articleCommentId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, articleComment: ArticleComment?) : RequestConfig<ArticleComment> {
        val localVariableBody = articleComment
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/articles/{id}/comments/{articleCommentId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"articleCommentId"+"}", encodeURIComponent(articleCommentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<ArticleComment>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdCommentsGet(id: kotlin.String, fields: kotlin.String? = "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<ArticleComment> {
        val localVarResponse = articlesIdCommentsGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ArticleComment>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<ArticleComment>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdCommentsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<ArticleComment>?> {
        val localVariableConfig = articlesIdCommentsGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<ArticleComment>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdCommentsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun articlesIdCommentsGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/articles/{id}/comments".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param draftId The ID of an existing draft that should be published. This parameter is optional. (optional)
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param articleComment  (optional)
     * @return ArticleComment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdCommentsPost(id: kotlin.String, draftId: kotlin.String? = null, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))", articleComment: ArticleComment? = null) : ArticleComment {
        val localVarResponse = articlesIdCommentsPostWithHttpInfo(id = id, draftId = draftId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, articleComment = articleComment)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ArticleComment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param draftId The ID of an existing draft that should be published. This parameter is optional. (optional)
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param articleComment  (optional)
     * @return ApiResponse<ArticleComment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdCommentsPostWithHttpInfo(id: kotlin.String, draftId: kotlin.String?, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, articleComment: ArticleComment?) : ApiResponse<ArticleComment?> {
        val localVariableConfig = articlesIdCommentsPostRequestConfig(id = id, draftId = draftId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, articleComment = articleComment)

        return request<ArticleComment, ArticleComment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdCommentsPost
     *
     * @param id 
     * @param draftId The ID of an existing draft that should be published. This parameter is optional. (optional)
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param articleComment  (optional)
     * @return RequestConfig
     */
    fun articlesIdCommentsPostRequestConfig(id: kotlin.String, draftId: kotlin.String?, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, articleComment: ArticleComment?) : RequestConfig<ArticleComment> {
        val localVariableBody = articleComment
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (draftId != null) {
                    put("draftId", listOf(draftId.toString()))
                }
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/articles/{id}/comments".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdDelete(id: kotlin.String) : Unit {
        val localVarResponse = articlesIdDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = articlesIdDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun articlesIdDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/articles/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @return Article
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdGet(id: kotlin.String, fields: kotlin.String? = "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)") : Article {
        val localVarResponse = articlesIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Article
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @return ApiResponse<Article?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<Article?> {
        val localVariableConfig = articlesIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, Article>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @return RequestConfig
     */
    fun articlesIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/articles/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @return Article
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdParentArticleGet(id: kotlin.String, fields: kotlin.String? = "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)") : Article {
        val localVarResponse = articlesIdParentArticleGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Article
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @return ApiResponse<Article?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdParentArticleGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<Article?> {
        val localVariableConfig = articlesIdParentArticleGetRequestConfig(id = id, fields = fields)

        return request<Unit, Article>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdParentArticleGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @return RequestConfig
     */
    fun articlesIdParentArticleGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/articles/{id}/parentArticle".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires Apply Commands Silently permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param article  (optional)
     * @return Article
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdPost(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)", article: Article? = null) : Article {
        val localVarResponse = articlesIdPostWithHttpInfo(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, article = article)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Article
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires Apply Commands Silently permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param article  (optional)
     * @return ApiResponse<Article?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdPostWithHttpInfo(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, article: Article?) : ApiResponse<Article?> {
        val localVariableConfig = articlesIdPostRequestConfig(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, article = article)

        return request<Article, Article>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdPost
     *
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires Apply Commands Silently permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param article  (optional)
     * @return RequestConfig
     */
    fun articlesIdPostRequestConfig(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, article: Article?) : RequestConfig<Article> {
        val localVariableBody = article
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/articles/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<Tag>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdTagsGet(id: kotlin.String, fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId)", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<Tag> {
        val localVarResponse = articlesIdTagsGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Tag>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<Tag>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdTagsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<Tag>?> {
        val localVariableConfig = articlesIdTagsGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<Tag>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdTagsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun articlesIdTagsGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/articles/{id}/tags".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param tag  (optional)
     * @return Tag
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdTagsPost(id: kotlin.String, fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId)", tag: Tag? = null) : Tag {
        val localVarResponse = articlesIdTagsPostWithHttpInfo(id = id, fields = fields, tag = tag)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Tag
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param tag  (optional)
     * @return ApiResponse<Tag?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdTagsPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, tag: Tag?) : ApiResponse<Tag?> {
        val localVariableConfig = articlesIdTagsPostRequestConfig(id = id, fields = fields, tag = tag)

        return request<Tag, Tag>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdTagsPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param tag  (optional)
     * @return RequestConfig
     */
    fun articlesIdTagsPostRequestConfig(id: kotlin.String, fields: kotlin.String?, tag: Tag?) : RequestConfig<Tag> {
        val localVariableBody = tag
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/articles/{id}/tags".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param tagId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdTagsTagIdDelete(id: kotlin.String, tagId: kotlin.String) : Unit {
        val localVarResponse = articlesIdTagsTagIdDeleteWithHttpInfo(id = id, tagId = tagId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param tagId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdTagsTagIdDeleteWithHttpInfo(id: kotlin.String, tagId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = articlesIdTagsTagIdDeleteRequestConfig(id = id, tagId = tagId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdTagsTagIdDelete
     *
     * @param id 
     * @param tagId 
     * @return RequestConfig
     */
    fun articlesIdTagsTagIdDeleteRequestConfig(id: kotlin.String, tagId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/articles/{id}/tags/{tagId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"tagId"+"}", encodeURIComponent(tagId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param tagId 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @return Tag
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesIdTagsTagIdGet(id: kotlin.String, tagId: kotlin.String, fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId)") : Tag {
        val localVarResponse = articlesIdTagsTagIdGetWithHttpInfo(id = id, tagId = tagId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Tag
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param tagId 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @return ApiResponse<Tag?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesIdTagsTagIdGetWithHttpInfo(id: kotlin.String, tagId: kotlin.String, fields: kotlin.String?) : ApiResponse<Tag?> {
        val localVariableConfig = articlesIdTagsTagIdGetRequestConfig(id = id, tagId = tagId, fields = fields)

        return request<Unit, Tag>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesIdTagsTagIdGet
     *
     * @param id 
     * @param tagId 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @return RequestConfig
     */
    fun articlesIdTagsTagIdGetRequestConfig(id: kotlin.String, tagId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/articles/{id}/tags/{tagId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"tagId"+"}", encodeURIComponent(tagId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param draftId ID of a draft to publish as a new article. If no &#x60;draftId&#x60; is provided, the article is created from scratch. In this case, you must specify the project in the request payload. (optional)
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires Apply Commands Silently permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param article  (optional)
     * @return Article
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun articlesPost(draftId: kotlin.String? = null, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)", article: Article? = null) : Article {
        val localVarResponse = articlesPostWithHttpInfo(draftId = draftId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, article = article)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Article
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param draftId ID of a draft to publish as a new article. If no &#x60;draftId&#x60; is provided, the article is created from scratch. In this case, you must specify the project in the request payload. (optional)
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires Apply Commands Silently permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param article  (optional)
     * @return ApiResponse<Article?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun articlesPostWithHttpInfo(draftId: kotlin.String?, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, article: Article?) : ApiResponse<Article?> {
        val localVariableConfig = articlesPostRequestConfig(draftId = draftId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, article = article)

        return request<Article, Article>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation articlesPost
     *
     * @param draftId ID of a draft to publish as a new article. If no &#x60;draftId&#x60; is provided, the article is created from scratch. In this case, you must specify the project in the request payload. (optional)
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires Apply Commands Silently permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,content,created,id,idReadable,parentArticle($type,id,idReadable),project($type,id,name,shortName),summary,updated,updatedBy($type,id,login,ringId)")
     * @param article  (optional)
     * @return RequestConfig
     */
    fun articlesPostRequestConfig(draftId: kotlin.String?, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, article: Article?) : RequestConfig<Article> {
        val localVariableBody = article
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (draftId != null) {
                    put("draftId", listOf(draftId.toString()))
                }
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/articles",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,caret,commands($type,description,error,id),comment,id,issues($type,id,idReadable,numberInProject),query,suggestions($type,caret,completionEnd,completionStart,description,id,matchingEnd,matchingStart,option,prefix,suffix)")
     * @param commandList  (optional)
     * @return CommandList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun commandsAssistPost(fields: kotlin.String? = "$type,caret,commands($type,description,error,id),comment,id,issues($type,id,idReadable,numberInProject),query,suggestions($type,caret,completionEnd,completionStart,description,id,matchingEnd,matchingStart,option,prefix,suffix)", commandList: CommandList? = null) : CommandList {
        val localVarResponse = commandsAssistPostWithHttpInfo(fields = fields, commandList = commandList)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CommandList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,caret,commands($type,description,error,id),comment,id,issues($type,id,idReadable,numberInProject),query,suggestions($type,caret,completionEnd,completionStart,description,id,matchingEnd,matchingStart,option,prefix,suffix)")
     * @param commandList  (optional)
     * @return ApiResponse<CommandList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun commandsAssistPostWithHttpInfo(fields: kotlin.String?, commandList: CommandList?) : ApiResponse<CommandList?> {
        val localVariableConfig = commandsAssistPostRequestConfig(fields = fields, commandList = commandList)

        return request<CommandList, CommandList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation commandsAssistPost
     *
     * @param fields  (optional, default to "$type,caret,commands($type,description,error,id),comment,id,issues($type,id,idReadable,numberInProject),query,suggestions($type,caret,completionEnd,completionStart,description,id,matchingEnd,matchingStart,option,prefix,suffix)")
     * @param commandList  (optional)
     * @return RequestConfig
     */
    fun commandsAssistPostRequestConfig(fields: kotlin.String?, commandList: CommandList?) : RequestConfig<CommandList> {
        val localVariableBody = commandList
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/commands/assist",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,caret,commands($type,description,error,id),comment,id,issues($type,id,idReadable,numberInProject),query,suggestions($type,caret,completionEnd,completionStart,description,id,matchingEnd,matchingStart,option,prefix,suffix)")
     * @param commandList  (optional)
     * @return CommandList
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun commandsPost(muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,caret,commands($type,description,error,id),comment,id,issues($type,id,idReadable,numberInProject),query,suggestions($type,caret,completionEnd,completionStart,description,id,matchingEnd,matchingStart,option,prefix,suffix)", commandList: CommandList? = null) : CommandList {
        val localVarResponse = commandsPostWithHttpInfo(muteUpdateNotifications = muteUpdateNotifications, fields = fields, commandList = commandList)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CommandList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,caret,commands($type,description,error,id),comment,id,issues($type,id,idReadable,numberInProject),query,suggestions($type,caret,completionEnd,completionStart,description,id,matchingEnd,matchingStart,option,prefix,suffix)")
     * @param commandList  (optional)
     * @return ApiResponse<CommandList?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun commandsPostWithHttpInfo(muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, commandList: CommandList?) : ApiResponse<CommandList?> {
        val localVariableConfig = commandsPostRequestConfig(muteUpdateNotifications = muteUpdateNotifications, fields = fields, commandList = commandList)

        return request<CommandList, CommandList>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation commandsPost
     *
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,caret,commands($type,description,error,id),comment,id,issues($type,id,idReadable,numberInProject),query,suggestions($type,caret,completionEnd,completionStart,description,id,matchingEnd,matchingStart,option,prefix,suffix)")
     * @param commandList  (optional)
     * @return RequestConfig
     */
    fun commandsPostRequestConfig(muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, commandList: CommandList?) : RequestConfig<CommandList> {
        val localVariableBody = commandList
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/commands",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,allUsersGroup,id,name,ringId")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<UserGroup>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun groupsGet(fields: kotlin.String? = "$type,allUsersGroup,id,name,ringId", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<UserGroup> {
        val localVarResponse = groupsGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UserGroup>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,allUsersGroup,id,name,ringId")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<UserGroup>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun groupsGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<UserGroup>?> {
        val localVariableConfig = groupsGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<UserGroup>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation groupsGet
     *
     * @param fields  (optional, default to "$type,allUsersGroup,id,name,ringId")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun groupsGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/groups",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,allUsersGroup,id,name,ringId")
     * @return UserGroup
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun groupsIdGet(id: kotlin.String, fields: kotlin.String? = "$type,allUsersGroup,id,name,ringId") : UserGroup {
        val localVarResponse = groupsIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserGroup
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,allUsersGroup,id,name,ringId")
     * @return ApiResponse<UserGroup?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun groupsIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<UserGroup?> {
        val localVariableConfig = groupsIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, UserGroup>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation groupsIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,allUsersGroup,id,name,ringId")
     * @return RequestConfig
     */
    fun groupsIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/groups/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<IssueLinkType>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issueLinkTypesGet(fields: kotlin.String? = "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<IssueLinkType> {
        val localVarResponse = issueLinkTypesGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IssueLinkType>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<IssueLinkType>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issueLinkTypesGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<IssueLinkType>?> {
        val localVariableConfig = issueLinkTypesGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<IssueLinkType>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issueLinkTypesGet
     *
     * @param fields  (optional, default to "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun issueLinkTypesGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issueLinkTypes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issueLinkTypesIdDelete(id: kotlin.String) : Unit {
        val localVarResponse = issueLinkTypesIdDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun issueLinkTypesIdDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = issueLinkTypesIdDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issueLinkTypesIdDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun issueLinkTypesIdDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/issueLinkTypes/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource")
     * @return IssueLinkType
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issueLinkTypesIdGet(id: kotlin.String, fields: kotlin.String? = "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource") : IssueLinkType {
        val localVarResponse = issueLinkTypesIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueLinkType
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource")
     * @return ApiResponse<IssueLinkType?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issueLinkTypesIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<IssueLinkType?> {
        val localVariableConfig = issueLinkTypesIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, IssueLinkType>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issueLinkTypesIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource")
     * @return RequestConfig
     */
    fun issueLinkTypesIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issueLinkTypes/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource")
     * @param issueLinkType  (optional)
     * @return IssueLinkType
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issueLinkTypesIdPost(id: kotlin.String, fields: kotlin.String? = "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource", issueLinkType: IssueLinkType? = null) : IssueLinkType {
        val localVarResponse = issueLinkTypesIdPostWithHttpInfo(id = id, fields = fields, issueLinkType = issueLinkType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueLinkType
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource")
     * @param issueLinkType  (optional)
     * @return ApiResponse<IssueLinkType?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issueLinkTypesIdPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, issueLinkType: IssueLinkType?) : ApiResponse<IssueLinkType?> {
        val localVariableConfig = issueLinkTypesIdPostRequestConfig(id = id, fields = fields, issueLinkType = issueLinkType)

        return request<IssueLinkType, IssueLinkType>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issueLinkTypesIdPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource")
     * @param issueLinkType  (optional)
     * @return RequestConfig
     */
    fun issueLinkTypesIdPostRequestConfig(id: kotlin.String, fields: kotlin.String?, issueLinkType: IssueLinkType?) : RequestConfig<IssueLinkType> {
        val localVariableBody = issueLinkType
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issueLinkTypes/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource")
     * @param issueLinkType  (optional)
     * @return IssueLinkType
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issueLinkTypesPost(fields: kotlin.String? = "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource", issueLinkType: IssueLinkType? = null) : IssueLinkType {
        val localVarResponse = issueLinkTypesPostWithHttpInfo(fields = fields, issueLinkType = issueLinkType)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueLinkType
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource")
     * @param issueLinkType  (optional)
     * @return ApiResponse<IssueLinkType?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issueLinkTypesPostWithHttpInfo(fields: kotlin.String?, issueLinkType: IssueLinkType?) : ApiResponse<IssueLinkType?> {
        val localVariableConfig = issueLinkTypesPostRequestConfig(fields = fields, issueLinkType = issueLinkType)

        return request<IssueLinkType, IssueLinkType>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issueLinkTypesPost
     *
     * @param fields  (optional, default to "$type,aggregation,directed,id,localizedName,localizedSourceToTarget,localizedTargetToSource,name,readOnly,sourceToTarget,targetToSource")
     * @param issueLinkType  (optional)
     * @return RequestConfig
     */
    fun issueLinkTypesPostRequestConfig(fields: kotlin.String?, issueLinkType: IssueLinkType?) : RequestConfig<IssueLinkType> {
        val localVariableBody = issueLinkType
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issueLinkTypes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param query Issues search query. Read more about search syntax here: &lt;a href&#x3D;\&quot;https://www.jetbrains.com/help/youtrack/cloud/?Search-and-Command-Attributes\&quot;&gt;Search Query Reference&lt;/a&gt; (optional)
     * @param customFields &lt;p&gt;The name of the custom field to show in the response. When you use this parameter and request the custom field data in the request URL, the response only shows the requested custom fields instead of all of them.&lt;/p&gt;&lt;p&gt;To show more than one custom field, use this parameter several times.&lt;/p&gt;&lt;p&gt;See Sample 2 for reference.&lt;/p&gt; (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<Issue>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesGet(query: kotlin.String? = null, customFields: kotlin.String? = null, fields: kotlin.String? = "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<Issue> {
        val localVarResponse = issuesGetWithHttpInfo(query = query, customFields = customFields, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Issue>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param query Issues search query. Read more about search syntax here: &lt;a href&#x3D;\&quot;https://www.jetbrains.com/help/youtrack/cloud/?Search-and-Command-Attributes\&quot;&gt;Search Query Reference&lt;/a&gt; (optional)
     * @param customFields &lt;p&gt;The name of the custom field to show in the response. When you use this parameter and request the custom field data in the request URL, the response only shows the requested custom fields instead of all of them.&lt;/p&gt;&lt;p&gt;To show more than one custom field, use this parameter several times.&lt;/p&gt;&lt;p&gt;See Sample 2 for reference.&lt;/p&gt; (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<Issue>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesGetWithHttpInfo(query: kotlin.String?, customFields: kotlin.String?, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<Issue>?> {
        val localVariableConfig = issuesGetRequestConfig(query = query, customFields = customFields, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<Issue>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesGet
     *
     * @param query Issues search query. Read more about search syntax here: &lt;a href&#x3D;\&quot;https://www.jetbrains.com/help/youtrack/cloud/?Search-and-Command-Attributes\&quot;&gt;Search Query Reference&lt;/a&gt; (optional)
     * @param customFields &lt;p&gt;The name of the custom field to show in the response. When you use this parameter and request the custom field data in the request URL, the response only shows the requested custom fields instead of all of them.&lt;/p&gt;&lt;p&gt;To show more than one custom field, use this parameter several times.&lt;/p&gt;&lt;p&gt;See Sample 2 for reference.&lt;/p&gt; (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun issuesGetRequestConfig(query: kotlin.String?, customFields: kotlin.String?, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (query != null) {
                    put("query", listOf(query.toString()))
                }
                if (customFields != null) {
                    put("customFields", listOf(customFields.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,count,id")
     * @param issueCountResponse  (optional)
     * @return IssueCountResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesGetterCountPost(fields: kotlin.String? = "$type,count,id", issueCountResponse: IssueCountResponse? = null) : IssueCountResponse {
        val localVarResponse = issuesGetterCountPostWithHttpInfo(fields = fields, issueCountResponse = issueCountResponse)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueCountResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,count,id")
     * @param issueCountResponse  (optional)
     * @return ApiResponse<IssueCountResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesGetterCountPostWithHttpInfo(fields: kotlin.String?, issueCountResponse: IssueCountResponse?) : ApiResponse<IssueCountResponse?> {
        val localVariableConfig = issuesGetterCountPostRequestConfig(fields = fields, issueCountResponse = issueCountResponse)

        return request<IssueCountResponse, IssueCountResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesGetterCountPost
     *
     * @param fields  (optional, default to "$type,count,id")
     * @param issueCountResponse  (optional)
     * @return RequestConfig
     */
    fun issuesGetterCountPostRequestConfig(fields: kotlin.String?, issueCountResponse: IssueCountResponse?) : RequestConfig<IssueCountResponse> {
        val localVariableBody = issueCountResponse
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issuesGetter/count",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param activityItemId 
     * @param fields  (optional, default to "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp")
     * @return ActivityItem
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdActivitiesActivityItemIdGet(id: kotlin.String, activityItemId: kotlin.String, fields: kotlin.String? = "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp") : ActivityItem {
        val localVarResponse = issuesIdActivitiesActivityItemIdGetWithHttpInfo(id = id, activityItemId = activityItemId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ActivityItem
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param activityItemId 
     * @param fields  (optional, default to "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp")
     * @return ApiResponse<ActivityItem?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdActivitiesActivityItemIdGetWithHttpInfo(id: kotlin.String, activityItemId: kotlin.String, fields: kotlin.String?) : ApiResponse<ActivityItem?> {
        val localVariableConfig = issuesIdActivitiesActivityItemIdGetRequestConfig(id = id, activityItemId = activityItemId, fields = fields)

        return request<Unit, ActivityItem>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdActivitiesActivityItemIdGet
     *
     * @param id 
     * @param activityItemId 
     * @param fields  (optional, default to "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp")
     * @return RequestConfig
     */
    fun issuesIdActivitiesActivityItemIdGetRequestConfig(id: kotlin.String, activityItemId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/activities/{activityItemId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"activityItemId"+"}", encodeURIComponent(activityItemId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param categories  (optional)
     * @param reverse Indicates whether the order of returning activities is from newest to oldest or the opposite. If \&quot;false\&quot;, then the oldest activity item that matches a selected filter is returned first. If \&quot;true\&quot;, then the newest activity is returned first. By default, \&quot;false\&quot;. (optional)
     * @param start Start timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered to be 0. (optional)
     * @param end End timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered as Long.MAX_VALUE. (optional)
     * @param author Parameter to filter activities by the author. The database id or login, or Hub id, or &#39;me&#39; for the current logged in user could be specified. (optional)
     * @param fields  (optional, default to "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<ActivityItem>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdActivitiesGet(id: kotlin.String, categories: kotlin.String? = null, reverse: kotlin.Boolean? = null, start: kotlin.String? = null, end: kotlin.String? = null, author: kotlin.String? = null, fields: kotlin.String? = "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<ActivityItem> {
        val localVarResponse = issuesIdActivitiesGetWithHttpInfo(id = id, categories = categories, reverse = reverse, start = start, end = end, author = author, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ActivityItem>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param categories  (optional)
     * @param reverse Indicates whether the order of returning activities is from newest to oldest or the opposite. If \&quot;false\&quot;, then the oldest activity item that matches a selected filter is returned first. If \&quot;true\&quot;, then the newest activity is returned first. By default, \&quot;false\&quot;. (optional)
     * @param start Start timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered to be 0. (optional)
     * @param end End timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered as Long.MAX_VALUE. (optional)
     * @param author Parameter to filter activities by the author. The database id or login, or Hub id, or &#39;me&#39; for the current logged in user could be specified. (optional)
     * @param fields  (optional, default to "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<ActivityItem>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdActivitiesGetWithHttpInfo(id: kotlin.String, categories: kotlin.String?, reverse: kotlin.Boolean?, start: kotlin.String?, end: kotlin.String?, author: kotlin.String?, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<ActivityItem>?> {
        val localVariableConfig = issuesIdActivitiesGetRequestConfig(id = id, categories = categories, reverse = reverse, start = start, end = end, author = author, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<ActivityItem>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdActivitiesGet
     *
     * @param id 
     * @param categories  (optional)
     * @param reverse Indicates whether the order of returning activities is from newest to oldest or the opposite. If \&quot;false\&quot;, then the oldest activity item that matches a selected filter is returned first. If \&quot;true\&quot;, then the newest activity is returned first. By default, \&quot;false\&quot;. (optional)
     * @param start Start timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered to be 0. (optional)
     * @param end End timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered as Long.MAX_VALUE. (optional)
     * @param author Parameter to filter activities by the author. The database id or login, or Hub id, or &#39;me&#39; for the current logged in user could be specified. (optional)
     * @param fields  (optional, default to "$type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun issuesIdActivitiesGetRequestConfig(id: kotlin.String, categories: kotlin.String?, reverse: kotlin.Boolean?, start: kotlin.String?, end: kotlin.String?, author: kotlin.String?, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (categories != null) {
                    put("categories", listOf(categories.toString()))
                }
                if (reverse != null) {
                    put("reverse", listOf(reverse.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (end != null) {
                    put("end", listOf(end.toString()))
                }
                if (author != null) {
                    put("author", listOf(author.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/activities".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param categories  (optional)
     * @param reverse Indicates whether the order of returning activities is from newest to oldest or the opposite. If \&quot;false\&quot;, then the oldest activity item that matches a selected filter is returned first. If \&quot;true\&quot;, then the newest activity is returned first. By default, \&quot;false\&quot;. (optional)
     * @param start Start timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered to be 0. (optional)
     * @param end End timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered as Long.MAX_VALUE. (optional)
     * @param author Parameter to filter activities by the author. The database id or login, or Hub id, or &#39;me&#39; for the current logged in user could be specified. (optional)
     * @param cursor  (optional)
     * @param activityId ID of the activity that should be included in the page. The activity is allocated to the middle of the page. (optional)
     * @param fields  (optional, default to "$type,activities($type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp),afterCursor,beforeCursor,hasAfter,hasBefore,id")
     * @return ActivityCursorPage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdActivitiesPageGet(id: kotlin.String, categories: kotlin.String? = null, reverse: kotlin.Boolean? = null, start: kotlin.String? = null, end: kotlin.String? = null, author: kotlin.String? = null, cursor: kotlin.String? = null, activityId: kotlin.String? = null, fields: kotlin.String? = "$type,activities($type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp),afterCursor,beforeCursor,hasAfter,hasBefore,id") : ActivityCursorPage {
        val localVarResponse = issuesIdActivitiesPageGetWithHttpInfo(id = id, categories = categories, reverse = reverse, start = start, end = end, author = author, cursor = cursor, activityId = activityId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ActivityCursorPage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param categories  (optional)
     * @param reverse Indicates whether the order of returning activities is from newest to oldest or the opposite. If \&quot;false\&quot;, then the oldest activity item that matches a selected filter is returned first. If \&quot;true\&quot;, then the newest activity is returned first. By default, \&quot;false\&quot;. (optional)
     * @param start Start timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered to be 0. (optional)
     * @param end End timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered as Long.MAX_VALUE. (optional)
     * @param author Parameter to filter activities by the author. The database id or login, or Hub id, or &#39;me&#39; for the current logged in user could be specified. (optional)
     * @param cursor  (optional)
     * @param activityId ID of the activity that should be included in the page. The activity is allocated to the middle of the page. (optional)
     * @param fields  (optional, default to "$type,activities($type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp),afterCursor,beforeCursor,hasAfter,hasBefore,id")
     * @return ApiResponse<ActivityCursorPage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdActivitiesPageGetWithHttpInfo(id: kotlin.String, categories: kotlin.String?, reverse: kotlin.Boolean?, start: kotlin.String?, end: kotlin.String?, author: kotlin.String?, cursor: kotlin.String?, activityId: kotlin.String?, fields: kotlin.String?) : ApiResponse<ActivityCursorPage?> {
        val localVariableConfig = issuesIdActivitiesPageGetRequestConfig(id = id, categories = categories, reverse = reverse, start = start, end = end, author = author, cursor = cursor, activityId = activityId, fields = fields)

        return request<Unit, ActivityCursorPage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdActivitiesPageGet
     *
     * @param id 
     * @param categories  (optional)
     * @param reverse Indicates whether the order of returning activities is from newest to oldest or the opposite. If \&quot;false\&quot;, then the oldest activity item that matches a selected filter is returned first. If \&quot;true\&quot;, then the newest activity is returned first. By default, \&quot;false\&quot;. (optional)
     * @param start Start timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered to be 0. (optional)
     * @param end End timestamp of the time interval the activity timestamp belongs to. If the parameter is not set, it is considered as Long.MAX_VALUE. (optional)
     * @param author Parameter to filter activities by the author. The database id or login, or Hub id, or &#39;me&#39; for the current logged in user could be specified. (optional)
     * @param cursor  (optional)
     * @param activityId ID of the activity that should be included in the page. The activity is allocated to the middle of the page. (optional)
     * @param fields  (optional, default to "$type,activities($type,added,author($type,id,login,ringId),category($type,id),field($type,customField($type,fieldType($type,id),id,localizedName,name),id,name),id,removed,target,targetMember,timestamp),afterCursor,beforeCursor,hasAfter,hasBefore,id")
     * @return RequestConfig
     */
    fun issuesIdActivitiesPageGetRequestConfig(id: kotlin.String, categories: kotlin.String?, reverse: kotlin.Boolean?, start: kotlin.String?, end: kotlin.String?, author: kotlin.String?, cursor: kotlin.String?, activityId: kotlin.String?, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (categories != null) {
                    put("categories", listOf(categories.toString()))
                }
                if (reverse != null) {
                    put("reverse", listOf(reverse.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (end != null) {
                    put("end", listOf(end.toString()))
                }
                if (author != null) {
                    put("author", listOf(author.toString()))
                }
                if (cursor != null) {
                    put("cursor", listOf(cursor.toString()))
                }
                if (activityId != null) {
                    put("activityId", listOf(activityId.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/activitiesPage".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<IssueAttachment>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdAttachmentsGet(id: kotlin.String, fields: kotlin.String? = "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<IssueAttachment> {
        val localVarResponse = issuesIdAttachmentsGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IssueAttachment>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<IssueAttachment>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdAttachmentsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<IssueAttachment>?> {
        val localVariableConfig = issuesIdAttachmentsGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<IssueAttachment>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdAttachmentsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun issuesIdAttachmentsGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/attachments".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueAttachmentId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdAttachmentsIssueAttachmentIdDelete(id: kotlin.String, issueAttachmentId: kotlin.String) : Unit {
        val localVarResponse = issuesIdAttachmentsIssueAttachmentIdDeleteWithHttpInfo(id = id, issueAttachmentId = issueAttachmentId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueAttachmentId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdAttachmentsIssueAttachmentIdDeleteWithHttpInfo(id: kotlin.String, issueAttachmentId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = issuesIdAttachmentsIssueAttachmentIdDeleteRequestConfig(id = id, issueAttachmentId = issueAttachmentId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdAttachmentsIssueAttachmentIdDelete
     *
     * @param id 
     * @param issueAttachmentId 
     * @return RequestConfig
     */
    fun issuesIdAttachmentsIssueAttachmentIdDeleteRequestConfig(id: kotlin.String, issueAttachmentId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/issues/{id}/attachments/{issueAttachmentId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueAttachmentId"+"}", encodeURIComponent(issueAttachmentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueAttachmentId 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @return IssueAttachment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdAttachmentsIssueAttachmentIdGet(id: kotlin.String, issueAttachmentId: kotlin.String, fields: kotlin.String? = "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url") : IssueAttachment {
        val localVarResponse = issuesIdAttachmentsIssueAttachmentIdGetWithHttpInfo(id = id, issueAttachmentId = issueAttachmentId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueAttachment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueAttachmentId 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @return ApiResponse<IssueAttachment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdAttachmentsIssueAttachmentIdGetWithHttpInfo(id: kotlin.String, issueAttachmentId: kotlin.String, fields: kotlin.String?) : ApiResponse<IssueAttachment?> {
        val localVariableConfig = issuesIdAttachmentsIssueAttachmentIdGetRequestConfig(id = id, issueAttachmentId = issueAttachmentId, fields = fields)

        return request<Unit, IssueAttachment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdAttachmentsIssueAttachmentIdGet
     *
     * @param id 
     * @param issueAttachmentId 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @return RequestConfig
     */
    fun issuesIdAttachmentsIssueAttachmentIdGetRequestConfig(id: kotlin.String, issueAttachmentId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/attachments/{issueAttachmentId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueAttachmentId"+"}", encodeURIComponent(issueAttachmentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueAttachmentId 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param issueAttachment  (optional)
     * @return IssueAttachment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdAttachmentsIssueAttachmentIdPost(id: kotlin.String, issueAttachmentId: kotlin.String, fields: kotlin.String? = "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url", issueAttachment: IssueAttachment? = null) : IssueAttachment {
        val localVarResponse = issuesIdAttachmentsIssueAttachmentIdPostWithHttpInfo(id = id, issueAttachmentId = issueAttachmentId, fields = fields, issueAttachment = issueAttachment)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueAttachment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueAttachmentId 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param issueAttachment  (optional)
     * @return ApiResponse<IssueAttachment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdAttachmentsIssueAttachmentIdPostWithHttpInfo(id: kotlin.String, issueAttachmentId: kotlin.String, fields: kotlin.String?, issueAttachment: IssueAttachment?) : ApiResponse<IssueAttachment?> {
        val localVariableConfig = issuesIdAttachmentsIssueAttachmentIdPostRequestConfig(id = id, issueAttachmentId = issueAttachmentId, fields = fields, issueAttachment = issueAttachment)

        return request<IssueAttachment, IssueAttachment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdAttachmentsIssueAttachmentIdPost
     *
     * @param id 
     * @param issueAttachmentId 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param issueAttachment  (optional)
     * @return RequestConfig
     */
    fun issuesIdAttachmentsIssueAttachmentIdPostRequestConfig(id: kotlin.String, issueAttachmentId: kotlin.String, fields: kotlin.String?, issueAttachment: IssueAttachment?) : RequestConfig<IssueAttachment> {
        val localVariableBody = issueAttachment
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issues/{id}/attachments/{issueAttachmentId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueAttachmentId"+"}", encodeURIComponent(issueAttachmentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param files0  (optional)
     * @return kotlin.collections.List<IssueAttachment>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdAttachmentsPost(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url", files0: java.io.File? = null) : kotlin.collections.List<IssueAttachment> {
        val localVarResponse = issuesIdAttachmentsPostWithHttpInfo(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, files0 = files0)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IssueAttachment>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param files0  (optional)
     * @return ApiResponse<kotlin.collections.List<IssueAttachment>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdAttachmentsPostWithHttpInfo(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, files0: java.io.File?) : ApiResponse<kotlin.collections.List<IssueAttachment>?> {
        val localVariableConfig = issuesIdAttachmentsPostRequestConfig(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, files0 = files0)

        return request<Map<String, PartConfig<*>>, kotlin.collections.List<IssueAttachment>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdAttachmentsPost
     *
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),charset,created,extension,id,metaData,mimeType,name,size,updated,url")
     * @param files0  (optional)
     * @return RequestConfig
     */
    fun issuesIdAttachmentsPostRequestConfig(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, files0: java.io.File?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "files[0]" to PartConfig(body = files0, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issues/{id}/attachments".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<IssueComment>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdCommentsGet(id: kotlin.String, fields: kotlin.String? = "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<IssueComment> {
        val localVarResponse = issuesIdCommentsGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IssueComment>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<IssueComment>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdCommentsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<IssueComment>?> {
        val localVariableConfig = issuesIdCommentsGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<IssueComment>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdCommentsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun issuesIdCommentsGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/comments".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueCommentId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdCommentsIssueCommentIdDelete(id: kotlin.String, issueCommentId: kotlin.String) : Unit {
        val localVarResponse = issuesIdCommentsIssueCommentIdDeleteWithHttpInfo(id = id, issueCommentId = issueCommentId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueCommentId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdCommentsIssueCommentIdDeleteWithHttpInfo(id: kotlin.String, issueCommentId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = issuesIdCommentsIssueCommentIdDeleteRequestConfig(id = id, issueCommentId = issueCommentId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdCommentsIssueCommentIdDelete
     *
     * @param id 
     * @param issueCommentId 
     * @return RequestConfig
     */
    fun issuesIdCommentsIssueCommentIdDeleteRequestConfig(id: kotlin.String, issueCommentId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/issues/{id}/comments/{issueCommentId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueCommentId"+"}", encodeURIComponent(issueCommentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueCommentId 
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @return IssueComment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdCommentsIssueCommentIdGet(id: kotlin.String, issueCommentId: kotlin.String, fields: kotlin.String? = "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))") : IssueComment {
        val localVarResponse = issuesIdCommentsIssueCommentIdGetWithHttpInfo(id = id, issueCommentId = issueCommentId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueComment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueCommentId 
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @return ApiResponse<IssueComment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdCommentsIssueCommentIdGetWithHttpInfo(id: kotlin.String, issueCommentId: kotlin.String, fields: kotlin.String?) : ApiResponse<IssueComment?> {
        val localVariableConfig = issuesIdCommentsIssueCommentIdGetRequestConfig(id = id, issueCommentId = issueCommentId, fields = fields)

        return request<Unit, IssueComment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdCommentsIssueCommentIdGet
     *
     * @param id 
     * @param issueCommentId 
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @return RequestConfig
     */
    fun issuesIdCommentsIssueCommentIdGetRequestConfig(id: kotlin.String, issueCommentId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/comments/{issueCommentId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueCommentId"+"}", encodeURIComponent(issueCommentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueCommentId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issueComment  (optional)
     * @return IssueComment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdCommentsIssueCommentIdPost(id: kotlin.String, issueCommentId: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))", issueComment: IssueComment? = null) : IssueComment {
        val localVarResponse = issuesIdCommentsIssueCommentIdPostWithHttpInfo(id = id, issueCommentId = issueCommentId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issueComment = issueComment)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueComment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueCommentId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issueComment  (optional)
     * @return ApiResponse<IssueComment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdCommentsIssueCommentIdPostWithHttpInfo(id: kotlin.String, issueCommentId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issueComment: IssueComment?) : ApiResponse<IssueComment?> {
        val localVariableConfig = issuesIdCommentsIssueCommentIdPostRequestConfig(id = id, issueCommentId = issueCommentId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issueComment = issueComment)

        return request<IssueComment, IssueComment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdCommentsIssueCommentIdPost
     *
     * @param id 
     * @param issueCommentId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issueComment  (optional)
     * @return RequestConfig
     */
    fun issuesIdCommentsIssueCommentIdPostRequestConfig(id: kotlin.String, issueCommentId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issueComment: IssueComment?) : RequestConfig<IssueComment> {
        val localVariableBody = issueComment
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issues/{id}/comments/{issueCommentId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueCommentId"+"}", encodeURIComponent(issueCommentId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param draftId ID of an existing draft that should be published. This parameter is optional. (optional)
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issueComment  (optional)
     * @return IssueComment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdCommentsPost(id: kotlin.String, draftId: kotlin.String? = null, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))", issueComment: IssueComment? = null) : IssueComment {
        val localVarResponse = issuesIdCommentsPostWithHttpInfo(id = id, draftId = draftId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issueComment = issueComment)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueComment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param draftId ID of an existing draft that should be published. This parameter is optional. (optional)
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issueComment  (optional)
     * @return ApiResponse<IssueComment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdCommentsPostWithHttpInfo(id: kotlin.String, draftId: kotlin.String?, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issueComment: IssueComment?) : ApiResponse<IssueComment?> {
        val localVariableConfig = issuesIdCommentsPostRequestConfig(id = id, draftId = draftId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issueComment = issueComment)

        return request<IssueComment, IssueComment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdCommentsPost
     *
     * @param id 
     * @param draftId ID of an existing draft that should be published. This parameter is optional. (optional)
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,attachments($type,id),author($type,id,login,ringId),created,deleted,id,text,updated,visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issueComment  (optional)
     * @return RequestConfig
     */
    fun issuesIdCommentsPostRequestConfig(id: kotlin.String, draftId: kotlin.String?, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issueComment: IssueComment?) : RequestConfig<IssueComment> {
        val localVariableBody = issueComment
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (draftId != null) {
                    put("draftId", listOf(draftId.toString()))
                }
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issues/{id}/comments".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,value($type,id,name)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<IssueCustomField>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdCustomFieldsGet(id: kotlin.String, fields: kotlin.String? = "$type,id,name,value($type,id,name)", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<IssueCustomField> {
        val localVarResponse = issuesIdCustomFieldsGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IssueCustomField>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,value($type,id,name)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<IssueCustomField>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdCustomFieldsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<IssueCustomField>?> {
        val localVariableConfig = issuesIdCustomFieldsGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<IssueCustomField>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdCustomFieldsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id,name,value($type,id,name)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun issuesIdCustomFieldsGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/customFields".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueCustomFieldId 
     * @param fields  (optional, default to "$type,id,name,value($type,id,name)")
     * @return IssueCustomField
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdCustomFieldsIssueCustomFieldIdGet(id: kotlin.String, issueCustomFieldId: kotlin.String, fields: kotlin.String? = "$type,id,name,value($type,id,name)") : IssueCustomField {
        val localVarResponse = issuesIdCustomFieldsIssueCustomFieldIdGetWithHttpInfo(id = id, issueCustomFieldId = issueCustomFieldId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueCustomField
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueCustomFieldId 
     * @param fields  (optional, default to "$type,id,name,value($type,id,name)")
     * @return ApiResponse<IssueCustomField?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdCustomFieldsIssueCustomFieldIdGetWithHttpInfo(id: kotlin.String, issueCustomFieldId: kotlin.String, fields: kotlin.String?) : ApiResponse<IssueCustomField?> {
        val localVariableConfig = issuesIdCustomFieldsIssueCustomFieldIdGetRequestConfig(id = id, issueCustomFieldId = issueCustomFieldId, fields = fields)

        return request<Unit, IssueCustomField>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdCustomFieldsIssueCustomFieldIdGet
     *
     * @param id 
     * @param issueCustomFieldId 
     * @param fields  (optional, default to "$type,id,name,value($type,id,name)")
     * @return RequestConfig
     */
    fun issuesIdCustomFieldsIssueCustomFieldIdGetRequestConfig(id: kotlin.String, issueCustomFieldId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/customFields/{issueCustomFieldId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueCustomFieldId"+"}", encodeURIComponent(issueCustomFieldId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueCustomFieldId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,id,name,value($type,id,name)")
     * @param issueCustomField  (optional)
     * @return IssueCustomField
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdCustomFieldsIssueCustomFieldIdPost(id: kotlin.String, issueCustomFieldId: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,id,name,value($type,id,name)", issueCustomField: IssueCustomField? = null) : IssueCustomField {
        val localVarResponse = issuesIdCustomFieldsIssueCustomFieldIdPostWithHttpInfo(id = id, issueCustomFieldId = issueCustomFieldId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issueCustomField = issueCustomField)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueCustomField
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueCustomFieldId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,id,name,value($type,id,name)")
     * @param issueCustomField  (optional)
     * @return ApiResponse<IssueCustomField?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdCustomFieldsIssueCustomFieldIdPostWithHttpInfo(id: kotlin.String, issueCustomFieldId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issueCustomField: IssueCustomField?) : ApiResponse<IssueCustomField?> {
        val localVariableConfig = issuesIdCustomFieldsIssueCustomFieldIdPostRequestConfig(id = id, issueCustomFieldId = issueCustomFieldId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issueCustomField = issueCustomField)

        return request<IssueCustomField, IssueCustomField>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdCustomFieldsIssueCustomFieldIdPost
     *
     * @param id 
     * @param issueCustomFieldId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,id,name,value($type,id,name)")
     * @param issueCustomField  (optional)
     * @return RequestConfig
     */
    fun issuesIdCustomFieldsIssueCustomFieldIdPostRequestConfig(id: kotlin.String, issueCustomFieldId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issueCustomField: IssueCustomField?) : RequestConfig<IssueCustomField> {
        val localVariableBody = issueCustomField
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issues/{id}/customFields/{issueCustomFieldId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueCustomFieldId"+"}", encodeURIComponent(issueCustomFieldId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdDelete(id: kotlin.String) : Unit {
        val localVarResponse = issuesIdDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = issuesIdDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun issuesIdDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/issues/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @return Issue
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdGet(id: kotlin.String, fields: kotlin.String? = "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))") : Issue {
        val localVarResponse = issuesIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Issue
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @return ApiResponse<Issue?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<Issue?> {
        val localVariableConfig = issuesIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, Issue>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @return RequestConfig
     */
    fun issuesIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,direction,id,linkType($type,id,localizedName,name)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<IssueLink>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdLinksGet(id: kotlin.String, fields: kotlin.String? = "$type,direction,id,linkType($type,id,localizedName,name)", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<IssueLink> {
        val localVarResponse = issuesIdLinksGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IssueLink>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,direction,id,linkType($type,id,localizedName,name)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<IssueLink>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdLinksGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<IssueLink>?> {
        val localVariableConfig = issuesIdLinksGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<IssueLink>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdLinksGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,direction,id,linkType($type,id,localizedName,name)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun issuesIdLinksGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/links".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueLinkId 
     * @param fields  (optional, default to "$type,direction,id,linkType($type,id,localizedName,name)")
     * @return IssueLink
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdLinksIssueLinkIdGet(id: kotlin.String, issueLinkId: kotlin.String, fields: kotlin.String? = "$type,direction,id,linkType($type,id,localizedName,name)") : IssueLink {
        val localVarResponse = issuesIdLinksIssueLinkIdGetWithHttpInfo(id = id, issueLinkId = issueLinkId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueLink
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueLinkId 
     * @param fields  (optional, default to "$type,direction,id,linkType($type,id,localizedName,name)")
     * @return ApiResponse<IssueLink?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdLinksIssueLinkIdGetWithHttpInfo(id: kotlin.String, issueLinkId: kotlin.String, fields: kotlin.String?) : ApiResponse<IssueLink?> {
        val localVariableConfig = issuesIdLinksIssueLinkIdGetRequestConfig(id = id, issueLinkId = issueLinkId, fields = fields)

        return request<Unit, IssueLink>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdLinksIssueLinkIdGet
     *
     * @param id 
     * @param issueLinkId 
     * @param fields  (optional, default to "$type,direction,id,linkType($type,id,localizedName,name)")
     * @return RequestConfig
     */
    fun issuesIdLinksIssueLinkIdGetRequestConfig(id: kotlin.String, issueLinkId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/links/{issueLinkId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueLinkId"+"}", encodeURIComponent(issueLinkId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueLinkId 
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<Issue>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdLinksIssueLinkIdIssuesGet(id: kotlin.String, issueLinkId: kotlin.String, fields: kotlin.String? = "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<Issue> {
        val localVarResponse = issuesIdLinksIssueLinkIdIssuesGetWithHttpInfo(id = id, issueLinkId = issueLinkId, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Issue>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueLinkId 
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<Issue>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdLinksIssueLinkIdIssuesGetWithHttpInfo(id: kotlin.String, issueLinkId: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<Issue>?> {
        val localVariableConfig = issuesIdLinksIssueLinkIdIssuesGetRequestConfig(id = id, issueLinkId = issueLinkId, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<Issue>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdLinksIssueLinkIdIssuesGet
     *
     * @param id 
     * @param issueLinkId 
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun issuesIdLinksIssueLinkIdIssuesGetRequestConfig(id: kotlin.String, issueLinkId: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/links/{issueLinkId}/issues".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueLinkId"+"}", encodeURIComponent(issueLinkId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueLinkId 
     * @param issueId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdLinksIssueLinkIdIssuesIssueIdDelete(id: kotlin.String, issueLinkId: kotlin.String, issueId: kotlin.String) : Unit {
        val localVarResponse = issuesIdLinksIssueLinkIdIssuesIssueIdDeleteWithHttpInfo(id = id, issueLinkId = issueLinkId, issueId = issueId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueLinkId 
     * @param issueId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdLinksIssueLinkIdIssuesIssueIdDeleteWithHttpInfo(id: kotlin.String, issueLinkId: kotlin.String, issueId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = issuesIdLinksIssueLinkIdIssuesIssueIdDeleteRequestConfig(id = id, issueLinkId = issueLinkId, issueId = issueId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdLinksIssueLinkIdIssuesIssueIdDelete
     *
     * @param id 
     * @param issueLinkId 
     * @param issueId 
     * @return RequestConfig
     */
    fun issuesIdLinksIssueLinkIdIssuesIssueIdDeleteRequestConfig(id: kotlin.String, issueLinkId: kotlin.String, issueId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/issues/{id}/links/{issueLinkId}/issues/{issueId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueLinkId"+"}", encodeURIComponent(issueLinkId.toString())).replace("{"+"issueId"+"}", encodeURIComponent(issueId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueLinkId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issue  (optional)
     * @return Issue
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdLinksIssueLinkIdIssuesPost(id: kotlin.String, issueLinkId: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))", issue: Issue? = null) : Issue {
        val localVarResponse = issuesIdLinksIssueLinkIdIssuesPostWithHttpInfo(id = id, issueLinkId = issueLinkId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issue = issue)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Issue
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueLinkId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issue  (optional)
     * @return ApiResponse<Issue?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdLinksIssueLinkIdIssuesPostWithHttpInfo(id: kotlin.String, issueLinkId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issue: Issue?) : ApiResponse<Issue?> {
        val localVariableConfig = issuesIdLinksIssueLinkIdIssuesPostRequestConfig(id = id, issueLinkId = issueLinkId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issue = issue)

        return request<Issue, Issue>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdLinksIssueLinkIdIssuesPost
     *
     * @param id 
     * @param issueLinkId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issue  (optional)
     * @return RequestConfig
     */
    fun issuesIdLinksIssueLinkIdIssuesPostRequestConfig(id: kotlin.String, issueLinkId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issue: Issue?) : RequestConfig<Issue> {
        val localVariableBody = issue
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issues/{id}/links/{issueLinkId}/issues".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueLinkId"+"}", encodeURIComponent(issueLinkId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issue  (optional)
     * @return Issue
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdPost(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))", issue: Issue? = null) : Issue {
        val localVarResponse = issuesIdPostWithHttpInfo(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issue = issue)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Issue
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issue  (optional)
     * @return ApiResponse<Issue?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdPostWithHttpInfo(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issue: Issue?) : ApiResponse<Issue?> {
        val localVariableConfig = issuesIdPostRequestConfig(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issue = issue)

        return request<Issue, Issue>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdPost
     *
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issue  (optional)
     * @return RequestConfig
     */
    fun issuesIdPostRequestConfig(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issue: Issue?) : RequestConfig<Issue> {
        val localVariableBody = issue
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issues/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @return Project
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdProjectGet(id: kotlin.String, fields: kotlin.String? = "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName") : Project {
        val localVarResponse = issuesIdProjectGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Project
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @return ApiResponse<Project?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdProjectGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<Project?> {
        val localVariableConfig = issuesIdProjectGetRequestConfig(id = id, fields = fields)

        return request<Unit, Project>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdProjectGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @return RequestConfig
     */
    fun issuesIdProjectGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/project".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @param project  (optional)
     * @return Project
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdProjectPost(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName", project: Project? = null) : Project {
        val localVarResponse = issuesIdProjectPostWithHttpInfo(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, project = project)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Project
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @param project  (optional)
     * @return ApiResponse<Project?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdProjectPostWithHttpInfo(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, project: Project?) : ApiResponse<Project?> {
        val localVariableConfig = issuesIdProjectPostRequestConfig(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, project = project)

        return request<Project, Project>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdProjectPost
     *
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,archived,customFields,id,leader($type,id,login,ringId),name,shortName")
     * @param project  (optional)
     * @return RequestConfig
     */
    fun issuesIdProjectPostRequestConfig(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, project: Project?) : RequestConfig<Project> {
        val localVariableBody = project
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issues/{id}/project".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,archived,finish,id,isDefault,name,start")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<Sprint>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdSprintsGet(id: kotlin.String, fields: kotlin.String? = "$type,archived,finish,id,isDefault,name,start", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<Sprint> {
        val localVarResponse = issuesIdSprintsGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Sprint>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,archived,finish,id,isDefault,name,start")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<Sprint>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdSprintsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<Sprint>?> {
        val localVariableConfig = issuesIdSprintsGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<Sprint>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdSprintsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,archived,finish,id,isDefault,name,start")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun issuesIdSprintsGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/sprints".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<Tag>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdTagsGet(id: kotlin.String, fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId)", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<Tag> {
        val localVarResponse = issuesIdTagsGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Tag>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<Tag>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdTagsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<Tag>?> {
        val localVariableConfig = issuesIdTagsGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<Tag>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdTagsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun issuesIdTagsGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/tags".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param tag  (optional)
     * @return Tag
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdTagsPost(id: kotlin.String, fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId)", tag: Tag? = null) : Tag {
        val localVarResponse = issuesIdTagsPostWithHttpInfo(id = id, fields = fields, tag = tag)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Tag
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param tag  (optional)
     * @return ApiResponse<Tag?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdTagsPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, tag: Tag?) : ApiResponse<Tag?> {
        val localVariableConfig = issuesIdTagsPostRequestConfig(id = id, fields = fields, tag = tag)

        return request<Tag, Tag>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdTagsPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param tag  (optional)
     * @return RequestConfig
     */
    fun issuesIdTagsPostRequestConfig(id: kotlin.String, fields: kotlin.String?, tag: Tag?) : RequestConfig<Tag> {
        val localVariableBody = tag
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issues/{id}/tags".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param tagId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdTagsTagIdDelete(id: kotlin.String, tagId: kotlin.String) : Unit {
        val localVarResponse = issuesIdTagsTagIdDeleteWithHttpInfo(id = id, tagId = tagId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param tagId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdTagsTagIdDeleteWithHttpInfo(id: kotlin.String, tagId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = issuesIdTagsTagIdDeleteRequestConfig(id = id, tagId = tagId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdTagsTagIdDelete
     *
     * @param id 
     * @param tagId 
     * @return RequestConfig
     */
    fun issuesIdTagsTagIdDeleteRequestConfig(id: kotlin.String, tagId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/issues/{id}/tags/{tagId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"tagId"+"}", encodeURIComponent(tagId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param tagId 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @return Tag
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdTagsTagIdGet(id: kotlin.String, tagId: kotlin.String, fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId)") : Tag {
        val localVarResponse = issuesIdTagsTagIdGetWithHttpInfo(id = id, tagId = tagId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Tag
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param tagId 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @return ApiResponse<Tag?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdTagsTagIdGetWithHttpInfo(id: kotlin.String, tagId: kotlin.String, fields: kotlin.String?) : ApiResponse<Tag?> {
        val localVariableConfig = issuesIdTagsTagIdGetRequestConfig(id = id, tagId = tagId, fields = fields)

        return request<Unit, Tag>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdTagsTagIdGet
     *
     * @param id 
     * @param tagId 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @return RequestConfig
     */
    fun issuesIdTagsTagIdGetRequestConfig(id: kotlin.String, tagId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/tags/{tagId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"tagId"+"}", encodeURIComponent(tagId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,enabled,id")
     * @return IssueTimeTracker
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdTimeTrackingGet(id: kotlin.String, fields: kotlin.String? = "$type,enabled,id") : IssueTimeTracker {
        val localVarResponse = issuesIdTimeTrackingGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueTimeTracker
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,enabled,id")
     * @return ApiResponse<IssueTimeTracker?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdTimeTrackingGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<IssueTimeTracker?> {
        val localVariableConfig = issuesIdTimeTrackingGetRequestConfig(id = id, fields = fields)

        return request<Unit, IssueTimeTracker>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdTimeTrackingGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,enabled,id")
     * @return RequestConfig
     */
    fun issuesIdTimeTrackingGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/timeTracking".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<IssueWorkItem>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdTimeTrackingWorkItemsGet(id: kotlin.String, fields: kotlin.String? = "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<IssueWorkItem> {
        val localVarResponse = issuesIdTimeTrackingWorkItemsGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IssueWorkItem>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<IssueWorkItem>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdTimeTrackingWorkItemsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<IssueWorkItem>?> {
        val localVariableConfig = issuesIdTimeTrackingWorkItemsGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<IssueWorkItem>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdTimeTrackingWorkItemsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun issuesIdTimeTrackingWorkItemsGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/timeTracking/workItems".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueWorkItemId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdTimeTrackingWorkItemsIssueWorkItemIdDelete(id: kotlin.String, issueWorkItemId: kotlin.String) : Unit {
        val localVarResponse = issuesIdTimeTrackingWorkItemsIssueWorkItemIdDeleteWithHttpInfo(id = id, issueWorkItemId = issueWorkItemId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueWorkItemId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdTimeTrackingWorkItemsIssueWorkItemIdDeleteWithHttpInfo(id: kotlin.String, issueWorkItemId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = issuesIdTimeTrackingWorkItemsIssueWorkItemIdDeleteRequestConfig(id = id, issueWorkItemId = issueWorkItemId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdTimeTrackingWorkItemsIssueWorkItemIdDelete
     *
     * @param id 
     * @param issueWorkItemId 
     * @return RequestConfig
     */
    fun issuesIdTimeTrackingWorkItemsIssueWorkItemIdDeleteRequestConfig(id: kotlin.String, issueWorkItemId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/issues/{id}/timeTracking/workItems/{issueWorkItemId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueWorkItemId"+"}", encodeURIComponent(issueWorkItemId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueWorkItemId 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @return IssueWorkItem
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdTimeTrackingWorkItemsIssueWorkItemIdGet(id: kotlin.String, issueWorkItemId: kotlin.String, fields: kotlin.String? = "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated") : IssueWorkItem {
        val localVarResponse = issuesIdTimeTrackingWorkItemsIssueWorkItemIdGetWithHttpInfo(id = id, issueWorkItemId = issueWorkItemId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueWorkItem
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueWorkItemId 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @return ApiResponse<IssueWorkItem?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdTimeTrackingWorkItemsIssueWorkItemIdGetWithHttpInfo(id: kotlin.String, issueWorkItemId: kotlin.String, fields: kotlin.String?) : ApiResponse<IssueWorkItem?> {
        val localVariableConfig = issuesIdTimeTrackingWorkItemsIssueWorkItemIdGetRequestConfig(id = id, issueWorkItemId = issueWorkItemId, fields = fields)

        return request<Unit, IssueWorkItem>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdTimeTrackingWorkItemsIssueWorkItemIdGet
     *
     * @param id 
     * @param issueWorkItemId 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @return RequestConfig
     */
    fun issuesIdTimeTrackingWorkItemsIssueWorkItemIdGetRequestConfig(id: kotlin.String, issueWorkItemId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/timeTracking/workItems/{issueWorkItemId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueWorkItemId"+"}", encodeURIComponent(issueWorkItemId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param issueWorkItemId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @param issueWorkItem  (optional)
     * @return IssueWorkItem
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdTimeTrackingWorkItemsIssueWorkItemIdPost(id: kotlin.String, issueWorkItemId: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated", issueWorkItem: IssueWorkItem? = null) : IssueWorkItem {
        val localVarResponse = issuesIdTimeTrackingWorkItemsIssueWorkItemIdPostWithHttpInfo(id = id, issueWorkItemId = issueWorkItemId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issueWorkItem = issueWorkItem)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueWorkItem
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param issueWorkItemId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @param issueWorkItem  (optional)
     * @return ApiResponse<IssueWorkItem?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdTimeTrackingWorkItemsIssueWorkItemIdPostWithHttpInfo(id: kotlin.String, issueWorkItemId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issueWorkItem: IssueWorkItem?) : ApiResponse<IssueWorkItem?> {
        val localVariableConfig = issuesIdTimeTrackingWorkItemsIssueWorkItemIdPostRequestConfig(id = id, issueWorkItemId = issueWorkItemId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issueWorkItem = issueWorkItem)

        return request<IssueWorkItem, IssueWorkItem>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdTimeTrackingWorkItemsIssueWorkItemIdPost
     *
     * @param id 
     * @param issueWorkItemId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @param issueWorkItem  (optional)
     * @return RequestConfig
     */
    fun issuesIdTimeTrackingWorkItemsIssueWorkItemIdPostRequestConfig(id: kotlin.String, issueWorkItemId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issueWorkItem: IssueWorkItem?) : RequestConfig<IssueWorkItem> {
        val localVariableBody = issueWorkItem
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issues/{id}/timeTracking/workItems/{issueWorkItemId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"issueWorkItemId"+"}", encodeURIComponent(issueWorkItemId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @param issueWorkItem  (optional)
     * @return IssueWorkItem
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdTimeTrackingWorkItemsPost(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated", issueWorkItem: IssueWorkItem? = null) : IssueWorkItem {
        val localVarResponse = issuesIdTimeTrackingWorkItemsPostWithHttpInfo(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issueWorkItem = issueWorkItem)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueWorkItem
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @param issueWorkItem  (optional)
     * @return ApiResponse<IssueWorkItem?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdTimeTrackingWorkItemsPostWithHttpInfo(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issueWorkItem: IssueWorkItem?) : ApiResponse<IssueWorkItem?> {
        val localVariableConfig = issuesIdTimeTrackingWorkItemsPostRequestConfig(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issueWorkItem = issueWorkItem)

        return request<IssueWorkItem, IssueWorkItem>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdTimeTrackingWorkItemsPost
     *
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @param issueWorkItem  (optional)
     * @return RequestConfig
     */
    fun issuesIdTimeTrackingWorkItemsPostRequestConfig(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issueWorkItem: IssueWorkItem?) : RequestConfig<IssueWorkItem> {
        val localVariableBody = issueWorkItem
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issues/{id}/timeTracking/workItems".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<VcsChange>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdVcsChangesGet(id: kotlin.String, fields: kotlin.String? = "$type,id", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<VcsChange> {
        val localVarResponse = issuesIdVcsChangesGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<VcsChange>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<VcsChange>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdVcsChangesGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<VcsChange>?> {
        val localVariableConfig = issuesIdVcsChangesGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<VcsChange>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdVcsChangesGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun issuesIdVcsChangesGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/vcsChanges".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on issue changes caused by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,id")
     * @param vcsChange  (optional)
     * @return VcsChange
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdVcsChangesPost(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,id", vcsChange: VcsChange? = null) : VcsChange {
        val localVarResponse = issuesIdVcsChangesPostWithHttpInfo(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, vcsChange = vcsChange)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VcsChange
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on issue changes caused by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,id")
     * @param vcsChange  (optional)
     * @return ApiResponse<VcsChange?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdVcsChangesPostWithHttpInfo(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, vcsChange: VcsChange?) : ApiResponse<VcsChange?> {
        val localVariableConfig = issuesIdVcsChangesPostRequestConfig(id = id, muteUpdateNotifications = muteUpdateNotifications, fields = fields, vcsChange = vcsChange)

        return request<VcsChange, VcsChange>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdVcsChangesPost
     *
     * @param id 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on issue changes caused by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,id")
     * @param vcsChange  (optional)
     * @return RequestConfig
     */
    fun issuesIdVcsChangesPostRequestConfig(id: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, vcsChange: VcsChange?) : RequestConfig<VcsChange> {
        val localVariableBody = vcsChange
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issues/{id}/vcsChanges".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param vcsChangeId 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdVcsChangesVcsChangeIdDelete(id: kotlin.String, vcsChangeId: kotlin.String) : Unit {
        val localVarResponse = issuesIdVcsChangesVcsChangeIdDeleteWithHttpInfo(id = id, vcsChangeId = vcsChangeId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param vcsChangeId 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdVcsChangesVcsChangeIdDeleteWithHttpInfo(id: kotlin.String, vcsChangeId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = issuesIdVcsChangesVcsChangeIdDeleteRequestConfig(id = id, vcsChangeId = vcsChangeId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdVcsChangesVcsChangeIdDelete
     *
     * @param id 
     * @param vcsChangeId 
     * @return RequestConfig
     */
    fun issuesIdVcsChangesVcsChangeIdDeleteRequestConfig(id: kotlin.String, vcsChangeId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/issues/{id}/vcsChanges/{vcsChangeId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"vcsChangeId"+"}", encodeURIComponent(vcsChangeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param vcsChangeId 
     * @param fields  (optional, default to "$type,id")
     * @return VcsChange
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdVcsChangesVcsChangeIdGet(id: kotlin.String, vcsChangeId: kotlin.String, fields: kotlin.String? = "$type,id") : VcsChange {
        val localVarResponse = issuesIdVcsChangesVcsChangeIdGetWithHttpInfo(id = id, vcsChangeId = vcsChangeId, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VcsChange
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param vcsChangeId 
     * @param fields  (optional, default to "$type,id")
     * @return ApiResponse<VcsChange?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdVcsChangesVcsChangeIdGetWithHttpInfo(id: kotlin.String, vcsChangeId: kotlin.String, fields: kotlin.String?) : ApiResponse<VcsChange?> {
        val localVariableConfig = issuesIdVcsChangesVcsChangeIdGetRequestConfig(id = id, vcsChangeId = vcsChangeId, fields = fields)

        return request<Unit, VcsChange>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdVcsChangesVcsChangeIdGet
     *
     * @param id 
     * @param vcsChangeId 
     * @param fields  (optional, default to "$type,id")
     * @return RequestConfig
     */
    fun issuesIdVcsChangesVcsChangeIdGetRequestConfig(id: kotlin.String, vcsChangeId: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issues/{id}/vcsChanges/{vcsChangeId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"vcsChangeId"+"}", encodeURIComponent(vcsChangeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param vcsChangeId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,id")
     * @param vcsChange  (optional)
     * @return VcsChange
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesIdVcsChangesVcsChangeIdPost(id: kotlin.String, vcsChangeId: kotlin.String, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,id", vcsChange: VcsChange? = null) : VcsChange {
        val localVarResponse = issuesIdVcsChangesVcsChangeIdPostWithHttpInfo(id = id, vcsChangeId = vcsChangeId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, vcsChange = vcsChange)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VcsChange
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param vcsChangeId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,id")
     * @param vcsChange  (optional)
     * @return ApiResponse<VcsChange?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesIdVcsChangesVcsChangeIdPostWithHttpInfo(id: kotlin.String, vcsChangeId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, vcsChange: VcsChange?) : ApiResponse<VcsChange?> {
        val localVariableConfig = issuesIdVcsChangesVcsChangeIdPostRequestConfig(id = id, vcsChangeId = vcsChangeId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, vcsChange = vcsChange)

        return request<VcsChange, VcsChange>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesIdVcsChangesVcsChangeIdPost
     *
     * @param id 
     * @param vcsChangeId 
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,id")
     * @param vcsChange  (optional)
     * @return RequestConfig
     */
    fun issuesIdVcsChangesVcsChangeIdPostRequestConfig(id: kotlin.String, vcsChangeId: kotlin.String, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, vcsChange: VcsChange?) : RequestConfig<VcsChange> {
        val localVariableBody = vcsChange
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issues/{id}/vcsChanges/{vcsChangeId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"vcsChangeId"+"}", encodeURIComponent(vcsChangeId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param draftId ID of a draft to report as the new issue. If no &#x60;draftId&#x60; is provided, the issue is created from scratch. In this case, you must specify the project in the request payload. (optional)
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issue  (optional)
     * @return Issue
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issuesPost(draftId: kotlin.String? = null, muteUpdateNotifications: kotlin.Boolean? = null, fields: kotlin.String? = "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))", issue: Issue? = null) : Issue {
        val localVarResponse = issuesPostWithHttpInfo(draftId = draftId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issue = issue)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Issue
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param draftId ID of a draft to report as the new issue. If no &#x60;draftId&#x60; is provided, the issue is created from scratch. In this case, you must specify the project in the request payload. (optional)
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issue  (optional)
     * @return ApiResponse<Issue?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issuesPostWithHttpInfo(draftId: kotlin.String?, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issue: Issue?) : ApiResponse<Issue?> {
        val localVariableConfig = issuesPostRequestConfig(draftId = draftId, muteUpdateNotifications = muteUpdateNotifications, fields = fields, issue = issue)

        return request<Issue, Issue>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issuesPost
     *
     * @param draftId ID of a draft to report as the new issue. If no &#x60;draftId&#x60; is provided, the issue is created from scratch. In this case, you must specify the project in the request payload. (optional)
     * @param muteUpdateNotifications Set this parameter to &#x60;true&#x60; if no notifications should be sent on changes made by this request. This doesn&#39;t mute notifications sent by any workflow rules. Using this parameter requires &lt;control&gt;Apply Commands Silently&lt;/control&gt; permission in all projects affected by the request. Available since 2021.3. (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param issue  (optional)
     * @return RequestConfig
     */
    fun issuesPostRequestConfig(draftId: kotlin.String?, muteUpdateNotifications: kotlin.Boolean?, fields: kotlin.String?, issue: Issue?) : RequestConfig<Issue> {
        val localVariableBody = issue
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (draftId != null) {
                    put("draftId", listOf(draftId.toString()))
                }
                if (muteUpdateNotifications != null) {
                    put("muteUpdateNotifications", listOf(muteUpdateNotifications.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issues",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId),query")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<SavedQuery>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun savedQueriesGet(fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId),query", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<SavedQuery> {
        val localVarResponse = savedQueriesGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SavedQuery>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId),query")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<SavedQuery>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun savedQueriesGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<SavedQuery>?> {
        val localVariableConfig = savedQueriesGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<SavedQuery>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation savedQueriesGet
     *
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId),query")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun savedQueriesGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/savedQueries",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun savedQueriesIdDelete(id: kotlin.String) : Unit {
        val localVarResponse = savedQueriesIdDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun savedQueriesIdDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = savedQueriesIdDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation savedQueriesIdDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun savedQueriesIdDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/savedQueries/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId),query")
     * @return SavedQuery
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun savedQueriesIdGet(id: kotlin.String, fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId),query") : SavedQuery {
        val localVarResponse = savedQueriesIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SavedQuery
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId),query")
     * @return ApiResponse<SavedQuery?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun savedQueriesIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<SavedQuery?> {
        val localVariableConfig = savedQueriesIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, SavedQuery>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation savedQueriesIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId),query")
     * @return RequestConfig
     */
    fun savedQueriesIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/savedQueries/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId),query")
     * @param savedQuery  (optional)
     * @return SavedQuery
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun savedQueriesIdPost(id: kotlin.String, fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId),query", savedQuery: SavedQuery? = null) : SavedQuery {
        val localVarResponse = savedQueriesIdPostWithHttpInfo(id = id, fields = fields, savedQuery = savedQuery)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SavedQuery
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId),query")
     * @param savedQuery  (optional)
     * @return ApiResponse<SavedQuery?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun savedQueriesIdPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, savedQuery: SavedQuery?) : ApiResponse<SavedQuery?> {
        val localVariableConfig = savedQueriesIdPostRequestConfig(id = id, fields = fields, savedQuery = savedQuery)

        return request<SavedQuery, SavedQuery>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation savedQueriesIdPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId),query")
     * @param savedQuery  (optional)
     * @return RequestConfig
     */
    fun savedQueriesIdPostRequestConfig(id: kotlin.String, fields: kotlin.String?, savedQuery: SavedQuery?) : RequestConfig<SavedQuery> {
        val localVariableBody = savedQuery
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/savedQueries/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId),query")
     * @param savedQuery  (optional)
     * @return SavedQuery
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun savedQueriesPost(fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId),query", savedQuery: SavedQuery? = null) : SavedQuery {
        val localVarResponse = savedQueriesPostWithHttpInfo(fields = fields, savedQuery = savedQuery)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SavedQuery
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId),query")
     * @param savedQuery  (optional)
     * @return ApiResponse<SavedQuery?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun savedQueriesPostWithHttpInfo(fields: kotlin.String?, savedQuery: SavedQuery?) : ApiResponse<SavedQuery?> {
        val localVariableConfig = savedQueriesPostRequestConfig(fields = fields, savedQuery = savedQuery)

        return request<SavedQuery, SavedQuery>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation savedQueriesPost
     *
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId),query")
     * @param savedQuery  (optional)
     * @return RequestConfig
     */
    fun savedQueriesPostRequestConfig(fields: kotlin.String?, savedQuery: SavedQuery?) : RequestConfig<SavedQuery> {
        val localVariableBody = savedQuery
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/savedQueries",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,suggestions($type,caret,completionEnd,completionStart,description,id,matchingEnd,matchingStart,option,prefix,suffix)")
     * @param searchSuggestions  (optional)
     * @return SearchSuggestions
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchAssistPost(fields: kotlin.String? = "$type,id,suggestions($type,caret,completionEnd,completionStart,description,id,matchingEnd,matchingStart,option,prefix,suffix)", searchSuggestions: SearchSuggestions? = null) : SearchSuggestions {
        val localVarResponse = searchAssistPostWithHttpInfo(fields = fields, searchSuggestions = searchSuggestions)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SearchSuggestions
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,suggestions($type,caret,completionEnd,completionStart,description,id,matchingEnd,matchingStart,option,prefix,suffix)")
     * @param searchSuggestions  (optional)
     * @return ApiResponse<SearchSuggestions?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchAssistPostWithHttpInfo(fields: kotlin.String?, searchSuggestions: SearchSuggestions?) : ApiResponse<SearchSuggestions?> {
        val localVariableConfig = searchAssistPostRequestConfig(fields = fields, searchSuggestions = searchSuggestions)

        return request<SearchSuggestions, SearchSuggestions>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation searchAssistPost
     *
     * @param fields  (optional, default to "$type,id,suggestions($type,caret,completionEnd,completionStart,description,id,matchingEnd,matchingStart,option,prefix,suffix)")
     * @param searchSuggestions  (optional)
     * @return RequestConfig
     */
    fun searchAssistPostRequestConfig(fields: kotlin.String?, searchSuggestions: SearchSuggestions?) : RequestConfig<SearchSuggestions> {
        val localVariableBody = searchSuggestions
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/search/assist",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<Tag>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tagsGet(fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId)", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<Tag> {
        val localVarResponse = tagsGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Tag>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<Tag>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tagsGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<Tag>?> {
        val localVariableConfig = tagsGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<Tag>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation tagsGet
     *
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun tagsGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/tags",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tagsIdDelete(id: kotlin.String) : Unit {
        val localVarResponse = tagsIdDeleteWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun tagsIdDeleteWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = tagsIdDeleteRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation tagsIdDelete
     *
     * @param id 
     * @return RequestConfig
     */
    fun tagsIdDeleteRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/tags/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @return Tag
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tagsIdGet(id: kotlin.String, fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId)") : Tag {
        val localVarResponse = tagsIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Tag
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @return ApiResponse<Tag?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tagsIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<Tag?> {
        val localVariableConfig = tagsIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, Tag>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation tagsIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @return RequestConfig
     */
    fun tagsIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/tags/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param customFields &lt;p&gt;The name of the custom field to show in the response. When you use this parameter and request the custom field data in the request URL, the response only shows the requested custom fields instead of all of them.&lt;/p&gt;&lt;p&gt;To show more than one custom field, use this parameter several times.&lt;/p&gt;&lt;p&gt;See Sample 2 for reference.&lt;/p&gt; (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<Issue>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tagsIdIssuesGet(id: kotlin.String, customFields: kotlin.String? = null, fields: kotlin.String? = "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<Issue> {
        val localVarResponse = tagsIdIssuesGetWithHttpInfo(id = id, customFields = customFields, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Issue>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param customFields &lt;p&gt;The name of the custom field to show in the response. When you use this parameter and request the custom field data in the request URL, the response only shows the requested custom fields instead of all of them.&lt;/p&gt;&lt;p&gt;To show more than one custom field, use this parameter several times.&lt;/p&gt;&lt;p&gt;See Sample 2 for reference.&lt;/p&gt; (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<Issue>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tagsIdIssuesGetWithHttpInfo(id: kotlin.String, customFields: kotlin.String?, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<Issue>?> {
        val localVariableConfig = tagsIdIssuesGetRequestConfig(id = id, customFields = customFields, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<Issue>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation tagsIdIssuesGet
     *
     * @param id 
     * @param customFields &lt;p&gt;The name of the custom field to show in the response. When you use this parameter and request the custom field data in the request URL, the response only shows the requested custom fields instead of all of them.&lt;/p&gt;&lt;p&gt;To show more than one custom field, use this parameter several times.&lt;/p&gt;&lt;p&gt;See Sample 2 for reference.&lt;/p&gt; (optional)
     * @param fields  (optional, default to "$type,created,customFields($type,id,name,value($type,id,name)),description,id,idReadable,links($type,direction,id,linkType($type,id,localizedName,name)),numberInProject,project($type,id,name,shortName),reporter($type,id,login,ringId),resolved,summary,updated,updater($type,id,login,ringId),visibility($type,id,permittedGroups($type,id,name,ringId),permittedUsers($type,id,login,ringId))")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun tagsIdIssuesGetRequestConfig(id: kotlin.String, customFields: kotlin.String?, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (customFields != null) {
                    put("customFields", listOf(customFields.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/tags/{id}/issues".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param tag  (optional)
     * @return Tag
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tagsIdPost(id: kotlin.String, fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId)", tag: Tag? = null) : Tag {
        val localVarResponse = tagsIdPostWithHttpInfo(id = id, fields = fields, tag = tag)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Tag
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param tag  (optional)
     * @return ApiResponse<Tag?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tagsIdPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, tag: Tag?) : ApiResponse<Tag?> {
        val localVariableConfig = tagsIdPostRequestConfig(id = id, fields = fields, tag = tag)

        return request<Tag, Tag>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation tagsIdPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param tag  (optional)
     * @return RequestConfig
     */
    fun tagsIdPostRequestConfig(id: kotlin.String, fields: kotlin.String?, tag: Tag?) : RequestConfig<Tag> {
        val localVariableBody = tag
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/tags/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param tag  (optional)
     * @return Tag
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tagsPost(fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId)", tag: Tag? = null) : Tag {
        val localVarResponse = tagsPostWithHttpInfo(fields = fields, tag = tag)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Tag
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param tag  (optional)
     * @return ApiResponse<Tag?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tagsPostWithHttpInfo(fields: kotlin.String?, tag: Tag?) : ApiResponse<Tag?> {
        val localVariableConfig = tagsPostRequestConfig(fields = fields, tag = tag)

        return request<Tag, Tag>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation tagsPost
     *
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param tag  (optional)
     * @return RequestConfig
     */
    fun tagsPostRequestConfig(fields: kotlin.String?, tag: Tag?) : RequestConfig<Tag> {
        val localVariableBody = tag
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/tags",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<User>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersGet(fields: kotlin.String? = "$type,banned,email,fullName,guest,id,login,ringId", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<User> {
        val localVarResponse = usersGetWithHttpInfo(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<User>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<User>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersGetWithHttpInfo(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<User>?> {
        val localVariableConfig = usersGetRequestConfig(fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<User>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usersGet
     *
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun usersGetRequestConfig(fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @return User
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdGet(id: kotlin.String, fields: kotlin.String? = "$type,banned,email,fullName,guest,id,login,ringId") : User {
        val localVarResponse = usersIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as User
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @return ApiResponse<User?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<User?> {
        val localVariableConfig = usersIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, User>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usersIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @return RequestConfig
     */
    fun usersIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,locale($type,community,id,language,locale,name),timezone($type,id,offset,presentation)")
     * @return GeneralUserProfile
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdProfilesGeneralGet(id: kotlin.String, fields: kotlin.String? = "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,locale($type,community,id,language,locale,name),timezone($type,id,offset,presentation)") : GeneralUserProfile {
        val localVarResponse = usersIdProfilesGeneralGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GeneralUserProfile
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,locale($type,community,id,language,locale,name),timezone($type,id,offset,presentation)")
     * @return ApiResponse<GeneralUserProfile?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdProfilesGeneralGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<GeneralUserProfile?> {
        val localVariableConfig = usersIdProfilesGeneralGetRequestConfig(id = id, fields = fields)

        return request<Unit, GeneralUserProfile>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usersIdProfilesGeneralGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,locale($type,community,id,language,locale,name),timezone($type,id,offset,presentation)")
     * @return RequestConfig
     */
    fun usersIdProfilesGeneralGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users/{id}/profiles/general".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,locale($type,community,id,language,locale,name),timezone($type,id,offset,presentation)")
     * @param generalUserProfile  (optional)
     * @return GeneralUserProfile
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdProfilesGeneralPost(id: kotlin.String, fields: kotlin.String? = "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,locale($type,community,id,language,locale,name),timezone($type,id,offset,presentation)", generalUserProfile: GeneralUserProfile? = null) : GeneralUserProfile {
        val localVarResponse = usersIdProfilesGeneralPostWithHttpInfo(id = id, fields = fields, generalUserProfile = generalUserProfile)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GeneralUserProfile
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,locale($type,community,id,language,locale,name),timezone($type,id,offset,presentation)")
     * @param generalUserProfile  (optional)
     * @return ApiResponse<GeneralUserProfile?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdProfilesGeneralPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, generalUserProfile: GeneralUserProfile?) : ApiResponse<GeneralUserProfile?> {
        val localVariableConfig = usersIdProfilesGeneralPostRequestConfig(id = id, fields = fields, generalUserProfile = generalUserProfile)

        return request<GeneralUserProfile, GeneralUserProfile>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usersIdProfilesGeneralPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,dateFieldFormat($type,datePattern,id,pattern,presentation),id,locale($type,community,id,language,locale,name),timezone($type,id,offset,presentation)")
     * @param generalUserProfile  (optional)
     * @return RequestConfig
     */
    fun usersIdProfilesGeneralPostRequestConfig(id: kotlin.String, fields: kotlin.String?, generalUserProfile: GeneralUserProfile?) : RequestConfig<GeneralUserProfile> {
        val localVariableBody = generalUserProfile
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/users/{id}/profiles/general".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return NotificationsUserProfile
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdProfilesNotificationsGet(id: kotlin.String, fields: kotlin.String? = "$type,id") : NotificationsUserProfile {
        val localVarResponse = usersIdProfilesNotificationsGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationsUserProfile
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return ApiResponse<NotificationsUserProfile?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdProfilesNotificationsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<NotificationsUserProfile?> {
        val localVariableConfig = usersIdProfilesNotificationsGetRequestConfig(id = id, fields = fields)

        return request<Unit, NotificationsUserProfile>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usersIdProfilesNotificationsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @return RequestConfig
     */
    fun usersIdProfilesNotificationsGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users/{id}/profiles/notifications".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param notificationsUserProfile  (optional)
     * @return NotificationsUserProfile
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdProfilesNotificationsPost(id: kotlin.String, fields: kotlin.String? = "$type,id", notificationsUserProfile: NotificationsUserProfile? = null) : NotificationsUserProfile {
        val localVarResponse = usersIdProfilesNotificationsPostWithHttpInfo(id = id, fields = fields, notificationsUserProfile = notificationsUserProfile)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NotificationsUserProfile
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param notificationsUserProfile  (optional)
     * @return ApiResponse<NotificationsUserProfile?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdProfilesNotificationsPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, notificationsUserProfile: NotificationsUserProfile?) : ApiResponse<NotificationsUserProfile?> {
        val localVariableConfig = usersIdProfilesNotificationsPostRequestConfig(id = id, fields = fields, notificationsUserProfile = notificationsUserProfile)

        return request<NotificationsUserProfile, NotificationsUserProfile>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usersIdProfilesNotificationsPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,id")
     * @param notificationsUserProfile  (optional)
     * @return RequestConfig
     */
    fun usersIdProfilesNotificationsPostRequestConfig(id: kotlin.String, fields: kotlin.String?, notificationsUserProfile: NotificationsUserProfile?) : RequestConfig<NotificationsUserProfile> {
        val localVariableBody = notificationsUserProfile
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/users/{id}/profiles/notifications".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,periodFormat($type,id)")
     * @return TimeTrackingUserProfile
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdProfilesTimetrackingGet(id: kotlin.String, fields: kotlin.String? = "$type,id,periodFormat($type,id)") : TimeTrackingUserProfile {
        val localVarResponse = usersIdProfilesTimetrackingGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TimeTrackingUserProfile
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,periodFormat($type,id)")
     * @return ApiResponse<TimeTrackingUserProfile?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdProfilesTimetrackingGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<TimeTrackingUserProfile?> {
        val localVariableConfig = usersIdProfilesTimetrackingGetRequestConfig(id = id, fields = fields)

        return request<Unit, TimeTrackingUserProfile>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usersIdProfilesTimetrackingGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id,periodFormat($type,id)")
     * @return RequestConfig
     */
    fun usersIdProfilesTimetrackingGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users/{id}/profiles/timetracking".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,periodFormat($type,id)")
     * @param timeTrackingUserProfile  (optional)
     * @return TimeTrackingUserProfile
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdProfilesTimetrackingPost(id: kotlin.String, fields: kotlin.String? = "$type,id,periodFormat($type,id)", timeTrackingUserProfile: TimeTrackingUserProfile? = null) : TimeTrackingUserProfile {
        val localVarResponse = usersIdProfilesTimetrackingPostWithHttpInfo(id = id, fields = fields, timeTrackingUserProfile = timeTrackingUserProfile)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TimeTrackingUserProfile
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,periodFormat($type,id)")
     * @param timeTrackingUserProfile  (optional)
     * @return ApiResponse<TimeTrackingUserProfile?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdProfilesTimetrackingPostWithHttpInfo(id: kotlin.String, fields: kotlin.String?, timeTrackingUserProfile: TimeTrackingUserProfile?) : ApiResponse<TimeTrackingUserProfile?> {
        val localVariableConfig = usersIdProfilesTimetrackingPostRequestConfig(id = id, fields = fields, timeTrackingUserProfile = timeTrackingUserProfile)

        return request<TimeTrackingUserProfile, TimeTrackingUserProfile>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usersIdProfilesTimetrackingPost
     *
     * @param id 
     * @param fields  (optional, default to "$type,id,periodFormat($type,id)")
     * @param timeTrackingUserProfile  (optional)
     * @return RequestConfig
     */
    fun usersIdProfilesTimetrackingPostRequestConfig(id: kotlin.String, fields: kotlin.String?, timeTrackingUserProfile: TimeTrackingUserProfile?) : RequestConfig<TimeTrackingUserProfile> {
        val localVariableBody = timeTrackingUserProfile
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/users/{id}/profiles/timetracking".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId),query")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<SavedQuery>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdSavedQueriesGet(id: kotlin.String, fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId),query", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<SavedQuery> {
        val localVarResponse = usersIdSavedQueriesGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SavedQuery>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId),query")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<SavedQuery>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdSavedQueriesGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<SavedQuery>?> {
        val localVariableConfig = usersIdSavedQueriesGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<SavedQuery>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usersIdSavedQueriesGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId),query")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun usersIdSavedQueriesGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users/{id}/savedQueries".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<Tag>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersIdTagsGet(id: kotlin.String, fields: kotlin.String? = "$type,id,name,owner($type,id,login,ringId)", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<Tag> {
        val localVarResponse = usersIdTagsGetWithHttpInfo(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Tag>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<Tag>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersIdTagsGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<Tag>?> {
        val localVariableConfig = usersIdTagsGetRequestConfig(id = id, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<Tag>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usersIdTagsGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,id,name,owner($type,id,login,ringId)")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun usersIdTagsGetRequestConfig(id: kotlin.String, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users/{id}/tags".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @return Me
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usersMeGet(fields: kotlin.String? = "$type,banned,email,fullName,guest,id,login,ringId") : Me {
        val localVarResponse = usersMeGetWithHttpInfo(fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Me
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @return ApiResponse<Me?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usersMeGetWithHttpInfo(fields: kotlin.String?) : ApiResponse<Me?> {
        val localVariableConfig = usersMeGetRequestConfig(fields = fields)

        return request<Unit, Me>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usersMeGet
     *
     * @param fields  (optional, default to "$type,banned,email,fullName,guest,id,login,ringId")
     * @return RequestConfig
     */
    fun usersMeGetRequestConfig(fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users/me",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param query Issues search query. Read more about search syntax here: &lt;a href&#x3D;\&quot;https://www.jetbrains.com/help/youtrack/cloud/?Search-and-Command-Attributes\&quot;&gt;Search Query Reference&lt;/a&gt; (optional)
     * @param startDate The start date of the interval for work items date. (optional)
     * @param endDate The end date of the interval for work items date. (optional)
     * @param start The start timestamp of the interval for work items date. (optional)
     * @param end The end timestamp of the interval for work items date. (optional)
     * @param createdStart The start timestamp of the interval for work items created date. (optional)
     * @param createdEnd The end timestamp of the interval for work items created date. (optional)
     * @param updatedStart The start timestamp of the interval for work items updated date. (optional)
     * @param updatedEnd The end timestamp of the interval for work items updated date. (optional)
     * @param author  (optional)
     * @param creator  (optional)
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return kotlin.collections.List<IssueWorkItem>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun workItemsGet(query: kotlin.String? = null, startDate: java.time.LocalDate? = null, endDate: java.time.LocalDate? = null, start: kotlin.Int? = null, end: kotlin.Int? = null, createdStart: kotlin.Int? = null, createdEnd: kotlin.Int? = null, updatedStart: kotlin.Int? = null, updatedEnd: kotlin.Int? = null, author: kotlin.String? = null, creator: kotlin.String? = null, fields: kotlin.String? = "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated", dollarSkip: kotlin.Int? = null, dollarTop: kotlin.Int? = null) : kotlin.collections.List<IssueWorkItem> {
        val localVarResponse = workItemsGetWithHttpInfo(query = query, startDate = startDate, endDate = endDate, start = start, end = end, createdStart = createdStart, createdEnd = createdEnd, updatedStart = updatedStart, updatedEnd = updatedEnd, author = author, creator = creator, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<IssueWorkItem>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param query Issues search query. Read more about search syntax here: &lt;a href&#x3D;\&quot;https://www.jetbrains.com/help/youtrack/cloud/?Search-and-Command-Attributes\&quot;&gt;Search Query Reference&lt;/a&gt; (optional)
     * @param startDate The start date of the interval for work items date. (optional)
     * @param endDate The end date of the interval for work items date. (optional)
     * @param start The start timestamp of the interval for work items date. (optional)
     * @param end The end timestamp of the interval for work items date. (optional)
     * @param createdStart The start timestamp of the interval for work items created date. (optional)
     * @param createdEnd The end timestamp of the interval for work items created date. (optional)
     * @param updatedStart The start timestamp of the interval for work items updated date. (optional)
     * @param updatedEnd The end timestamp of the interval for work items updated date. (optional)
     * @param author  (optional)
     * @param creator  (optional)
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return ApiResponse<kotlin.collections.List<IssueWorkItem>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun workItemsGetWithHttpInfo(query: kotlin.String?, startDate: java.time.LocalDate?, endDate: java.time.LocalDate?, start: kotlin.Int?, end: kotlin.Int?, createdStart: kotlin.Int?, createdEnd: kotlin.Int?, updatedStart: kotlin.Int?, updatedEnd: kotlin.Int?, author: kotlin.String?, creator: kotlin.String?, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : ApiResponse<kotlin.collections.List<IssueWorkItem>?> {
        val localVariableConfig = workItemsGetRequestConfig(query = query, startDate = startDate, endDate = endDate, start = start, end = end, createdStart = createdStart, createdEnd = createdEnd, updatedStart = updatedStart, updatedEnd = updatedEnd, author = author, creator = creator, fields = fields, dollarSkip = dollarSkip, dollarTop = dollarTop)

        return request<Unit, kotlin.collections.List<IssueWorkItem>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation workItemsGet
     *
     * @param query Issues search query. Read more about search syntax here: &lt;a href&#x3D;\&quot;https://www.jetbrains.com/help/youtrack/cloud/?Search-and-Command-Attributes\&quot;&gt;Search Query Reference&lt;/a&gt; (optional)
     * @param startDate The start date of the interval for work items date. (optional)
     * @param endDate The end date of the interval for work items date. (optional)
     * @param start The start timestamp of the interval for work items date. (optional)
     * @param end The end timestamp of the interval for work items date. (optional)
     * @param createdStart The start timestamp of the interval for work items created date. (optional)
     * @param createdEnd The end timestamp of the interval for work items created date. (optional)
     * @param updatedStart The start timestamp of the interval for work items updated date. (optional)
     * @param updatedEnd The end timestamp of the interval for work items updated date. (optional)
     * @param author  (optional)
     * @param creator  (optional)
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @param dollarSkip  (optional)
     * @param dollarTop  (optional)
     * @return RequestConfig
     */
    fun workItemsGetRequestConfig(query: kotlin.String?, startDate: java.time.LocalDate?, endDate: java.time.LocalDate?, start: kotlin.Int?, end: kotlin.Int?, createdStart: kotlin.Int?, createdEnd: kotlin.Int?, updatedStart: kotlin.Int?, updatedEnd: kotlin.Int?, author: kotlin.String?, creator: kotlin.String?, fields: kotlin.String?, dollarSkip: kotlin.Int?, dollarTop: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (query != null) {
                    put("query", listOf(query.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (end != null) {
                    put("end", listOf(end.toString()))
                }
                if (createdStart != null) {
                    put("createdStart", listOf(createdStart.toString()))
                }
                if (createdEnd != null) {
                    put("createdEnd", listOf(createdEnd.toString()))
                }
                if (updatedStart != null) {
                    put("updatedStart", listOf(updatedStart.toString()))
                }
                if (updatedEnd != null) {
                    put("updatedEnd", listOf(updatedEnd.toString()))
                }
                if (author != null) {
                    put("author", listOf(author.toString()))
                }
                if (creator != null) {
                    put("creator", listOf(creator.toString()))
                }
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
                if (dollarSkip != null) {
                    put("$skip", listOf(dollarSkip.toString()))
                }
                if (dollarTop != null) {
                    put("$top", listOf(dollarTop.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/workItems",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @return IssueWorkItem
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun workItemsIdGet(id: kotlin.String, fields: kotlin.String? = "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated") : IssueWorkItem {
        val localVarResponse = workItemsIdGetWithHttpInfo(id = id, fields = fields)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueWorkItem
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param id 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @return ApiResponse<IssueWorkItem?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun workItemsIdGetWithHttpInfo(id: kotlin.String, fields: kotlin.String?) : ApiResponse<IssueWorkItem?> {
        val localVariableConfig = workItemsIdGetRequestConfig(id = id, fields = fields)

        return request<Unit, IssueWorkItem>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation workItemsIdGet
     *
     * @param id 
     * @param fields  (optional, default to "$type,author($type,id,login,ringId),created,creator($type,id,login,ringId),date,duration($type,id),id,text,updated")
     * @return RequestConfig
     */
    fun workItemsIdGetRequestConfig(id: kotlin.String, fields: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (fields != null) {
                    put("fields", listOf(fields.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/workItems/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
